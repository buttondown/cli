/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/exports": {
    /** List Exports */
    get: operations["list_exports"];
    /** Create Export */
    post: operations["create_export"];
  };
  "/exports/{id}": {
    /**
     * Retrieve Export 
     * @description Retrieve a specific export by its ID
     */
    get: operations["retrieve_export"];
  };
  "/tags": {
    /** List Tags */
    get: operations["list_tags"];
    /** Create Tag */
    post: operations["create_tag"];
  };
  "/tags/{id}": {
    /**
     * Retrieve Tag 
     * @description Retrieve a specific tag by its ID
     */
    get: operations["retrieve_tag"];
    /**
     * Delete Tag 
     * @description Delete a tag
     */
    delete: operations["delete_tag"];
    /**
     * Update Tag 
     * @description Update a tag's properties
     */
    patch: operations["update_tag"];
  };
  "/tags/{id}/analytics": {
    /**
     * Retrieve Tag Analytics 
     * @description Retrieve analytics for a specific tag
     */
    get: operations["retrieve_tag_analytics"];
  };
  "/ping": {
    /** Ping */
    get: operations["ping"];
  };
  "/accounts/me": {
    /** Get Account */
    get: operations["get_account"];
  };
  "/images": {
    /** List Images */
    get: operations["list_images"];
    /** Create Image */
    post: operations["create_image"];
  };
  "/images/{id}": {
    /**
     * Delete Image 
     * @description Delete an uploaded image
     */
    delete: operations["delete_image"];
  };
  "/attachments": {
    /** List Attachments */
    get: operations["list_attachments"];
    /** Create Attachment */
    post: operations["create_attachment"];
  };
  "/attachments/{id}": {
    /**
     * Retrieve Attachment 
     * @description Retrieve an attachment
     */
    get: operations["retrieve_attachment"];
    /**
     * Delete Attachment 
     * @description Delete an attachment
     */
    delete: operations["delete_attachment"];
  };
  "/books": {
    /**
     * List Books 
     * @description List all books for the authenticated newsletter
     */
    get: operations["list_books"];
    /**
     * Create Book 
     * @description Create a new book
     */
    post: operations["create_book"];
  };
  "/books/{id}": {
    /**
     * Retrieve Book 
     * @description Retrieve a specific book by its ID
     */
    get: operations["retrieve_book"];
    /**
     * Delete Book 
     * @description Delete a book
     */
    delete: operations["delete_book"];
    /**
     * Update Book 
     * @description Update a book's properties
     */
    patch: operations["update_book"];
  };
  "/emails": {
    /** List Emails */
    get: operations["list_emails"];
    /** Create Email */
    post: operations["create_email"];
  };
  "/emails/{id}": {
    /**
     * Retrieve Email 
     * @description Retrieve a specific email by its ID
     */
    get: operations["retrieve_email"];
    /**
     * Delete Email 
     * @description Delete an email
     */
    delete: operations["delete_email"];
    /**
     * Update Email 
     * @description Update an email's properties
     */
    patch: operations["update_email"];
  };
  "/emails/{id}/history": {
    /**
     * Retrieve Email History 
     * @description Retrieve the edit history for a specific email
     */
    get: operations["retrieve_email_history"];
  };
  "/emails/{id}/history/body/{history_id}": {
    /**
     * Retrieve Email History By Id 
     * @description Retrieve a specific historical version of an email's body
     */
    get: operations["retrieve_email_history_by_id"];
  };
  "/emails/{id}/analytics": {
    /**
     * Retrieve Email Analytics 
     * @description Retrieve analytics for a specific email
     */
    get: operations["retrieve_email_analytics"];
  };
  "/emails/{id}/renders": {
    /**
     * Retrieve Email Renders 
     * @description Retrieve rendered HTML for a specific email
     */
    get: operations["retrieve_email_renders"];
  };
  "/emails/{id}/send-draft": {
    /**
     * Send Draft 
     * @description Send a draft email to specific recipients
     */
    post: operations["send_draft"];
  };
  "/subscribers": {
    /** List Subscribers */
    get: operations["list_subscribers"];
    /** Create Subscriber */
    post: operations["create_subscriber"];
  };
  "/subscribers/{id_or_email}": {
    /** Retrieve Subscriber */
    get: operations["retrieve_subscriber"];
    /** Delete Subscriber */
    delete: operations["delete_subscriber"];
    /** Update Subscriber */
    patch: operations["update_subscriber"];
  };
  "/subscribers/{id_or_email}/send-reminder": {
    /** Send Reminder */
    post: operations["send_reminder"];
  };
  "/subscribers/{id_or_email}/send-magic-link": {
    /** Send Magic Link To Subscriber */
    post: operations["send_magic_link_to_subscriber"];
  };
  "/subscribers/{id_or_email}/emails/{email_id}": {
    /** Send Email To */
    post: operations["send_email_to"];
  };
  "/subscribers/{id_or_email}/referrals": {
    /** Get Referrals */
    get: operations["get_referrals"];
  };
  "/subscribers/{id_or_email}/automations": {
    /** Get Automations */
    get: operations["get_automations"];
  };
  "/subscribers/{id_or_email}/automations/{automation_attempt_id}": {
    /** Update Automation Attempt */
    patch: operations["update_automation_attempt"];
  };
  "/subscribers/{id_or_email}/stripe-subscriptions": {
    /** Get Stripe Subscriptions */
    get: operations["get_stripe_subscriptions"];
  };
  "/newsletters": {
    /** List Newsletters */
    get: operations["list_newsletters"];
    /** Create Newsletter */
    post: operations["create_newsletter"];
  };
  "/newsletters/{id}": {
    /**
     * Delete Newsletter 
     * @description Delete a newsletter
     */
    delete: operations["delete_newsletter"];
    /**
     * Update Newsletter 
     * @description Update a newsletter's settings
     */
    patch: operations["update_newsletter"];
  };
  "/bulk_actions": {
    /** Create Bulk Action */
    post: operations["create_bulk_action"];
  };
  "/bulk_actions/{id}": {
    /**
     * Retrieve Bulk Action 
     * @description Retrieve the status of a bulk action
     */
    get: operations["retrieve_bulk_action"];
  };
  "/external_feeds": {
    /** List External Feed */
    get: operations["list_external_feed"];
    /** Create External Feed */
    post: operations["create_external_feed"];
  };
  "/external_feeds/{id}": {
    /**
     * Retrieve External Feed 
     * @description Retrieve a specific external feed by its ID
     */
    get: operations["retrieve_external_feed"];
    /**
     * Delete External Feed 
     * @description Delete an external feed
     */
    delete: operations["delete_external_feed"];
    /**
     * Update External Feed 
     * @description Update an external feed's properties
     */
    patch: operations["update_external_feed"];
  };
  "/external_feeds/{id}/items": {
    /**
     * Retrieve Items 
     * @description Retrieve items from an external feed
     */
    get: operations["retrieve_items"];
    /**
     * Poll Items 
     * @description Poll for new items in an external feed
     */
    post: operations["poll_items"];
  };
  "/automations": {
    /** List Automations */
    get: operations["list_automations"];
    /** Create Automation */
    post: operations["create_automation"];
  };
  "/automations/{id}": {
    /**
     * Retrieve Automation 
     * @description Retrieve a specific automation by its ID
     */
    get: operations["retrieve_automation"];
    /**
     * Delete Automation 
     * @description Delete an automation
     */
    delete: operations["delete_automation"];
    /**
     * Update Automation 
     * @description Update an automation's properties
     */
    patch: operations["update_automation"];
  };
  "/automations/{id}/invoke": {
    /**
     * Invoke Automation 
     * @description Manually trigger an automation
     */
    post: operations["invoke_automation"];
  };
  "/automations/{id}/analytics": {
    /**
     * Retrieve Automation Analytics 
     * @description Retrieve analytics data for an automation
     */
    get: operations["retrieve_automation_analytics"];
  };
  "/users": {
    /** List Users */
    get: operations["list_users"];
    /** Create User */
    post: operations["create_user"];
  };
  "/users/{id}": {
    /**
     * Retrieve User 
     * @description Retrieve a specific user by its ID
     */
    get: operations["retrieve_user"];
    /**
     * Delete User 
     * @description Delete a user
     */
    delete: operations["delete_user"];
    /**
     * Update User 
     * @description Update a user's properties
     */
    patch: operations["update_user"];
  };
  "/prices": {
    /** List Prices */
    get: operations["list_prices"];
    /** Create Price */
    post: operations["create_price"];
  };
  "/coupons": {
    /** List Coupons */
    get: operations["list_coupons"];
  };
  "/surveys": {
    /** List Surveys */
    get: operations["list_surveys"];
    /** Create Survey */
    post: operations["create_survey"];
  };
  "/surveys/{id}": {
    /**
     * Retrieve Survey 
     * @description Retrieve a specific survey by its ID
     */
    get: operations["retrieve_survey"];
    /**
     * Delete Survey 
     * @description Delete a survey
     */
    delete: operations["delete_survey"];
    /**
     * Update Survey 
     * @description Update a survey's properties
     */
    patch: operations["update_survey"];
  };
  "/forms": {
    /** List Forms */
    get: operations["list_forms"];
    /** Create Form */
    post: operations["create_form"];
  };
  "/forms/{id}": {
    /**
     * Retrieve Form 
     * @description Retrieve a specific form by its ID
     */
    get: operations["retrieve_form"];
    /**
     * Delete Form 
     * @description Delete a form
     */
    delete: operations["delete_form"];
    /**
     * Update Form 
     * @description Update a form's properties
     */
    patch: operations["update_form"];
  };
  "/api_requests/{id}": {
    /**
     * Retrieve Api Request 
     * @description Retrieve a specific API request by its ID
     */
    get: operations["retrieve_api_request"];
  };
  "/api_requests": {
    /** List Api Requests */
    get: operations["list_api_requests"];
  };
  "/advertising_units": {
    /** List Advertising Units */
    get: operations["list_advertising_units"];
    /** Create Advertising Unit */
    post: operations["create_advertising_unit"];
  };
  "/advertising_units/{id}": {
    /**
     * Delete Advertising Unit 
     * @description Delete an advertising unit
     */
    delete: operations["delete_advertising_unit"];
    /**
     * Update Advertising Unit 
     * @description Update an advertising unit's properties
     */
    patch: operations["update_advertising_unit"];
  };
  "/advertising_units/slots": {
    /**
     * List Advertising Slots 
     * @description List all advertising slots
     */
    get: operations["list_advertising_slots"];
  };
  "/advertising_units/slots/{id}": {
    /**
     * Update Advertising Slot 
     * @description Update an advertising slot's sponsor content
     */
    patch: operations["update_advertising_slot"];
  };
  "/webhooks": {
    /** List Webhooks */
    get: operations["list_webhooks"];
    /** Create Webhook */
    post: operations["create_webhook"];
  };
  "/webhooks/{id}": {
    /**
     * Retrieve Webhook 
     * @description Retrieve a specific webhook by its ID
     */
    get: operations["retrieve_webhook"];
    /**
     * Delete Webhook 
     * @description Delete a webhook
     */
    delete: operations["delete_webhook"];
    /**
     * Update Webhook 
     * @description Update a webhook's properties
     */
    patch: operations["update_webhook"];
  };
  "/webhooks/{id}/attempts": {
    /**
     * Retrieve Webhook Attempts 
     * @description Retrieve webhook attempts for a specific webhook
     */
    get: operations["retrieve_webhook_attempts"];
  };
  "/webhooks/{id}/test": {
    /**
     * Test Webhook 
     * @description Send a test event to a webhook
     */
    post: operations["test_webhook"];
  };
  "/comments": {
    /** List Comments */
    get: operations["list_comments"];
    /**
     * Create Comment 
     * @description Create a new comment or reply to an existing comment. Authors can respond to comments at the given author.
     */
    post: operations["create_comment"];
  };
  "/comments/{id}": {
    /**
     * Retrieve Comment 
     * @description Retrieve a specific comment by its ID
     */
    get: operations["retrieve_comment"];
    /**
     * Delete Comment 
     * @description Delete a comment. Only the comment owner (subscriber) or the newsletter author can delete a comment.
     */
    delete: operations["delete_comment"];
  };
  "/survey_responses": {
    /** Retrieve Survey Responses */
    get: operations["retrieve_survey_responses"];
    /** Create Survey Response */
    post: operations["create_survey_response"];
  };
  "/survey_responses/{id}": {
    /**
     * Update Survey Response 
     * @description Update a survey response's text. Only the response owner (subscriber) can update their response.
     */
    patch: operations["update_survey_response"];
  };
  "/events": {
    /** List Events */
    get: operations["list_events"];
  };
  "/events/{id}": {
    /**
     * Get Event 
     * @description Retrieve a specific event by its ID
     */
    get: operations["get_event"];
  };
  "/notes": {
    /** List Notes */
    get: operations["list_notes"];
    /** Create Note Endpoint */
    post: operations["create_note_endpoint"];
  };
  "/notes/{id}": {
    /**
     * Delete Note Endpoint 
     * @description Delete a note
     */
    delete: operations["delete_note_endpoint"];
  };
  "/public/emails/{username}": {
    /**
     * Search public emails 
     * @description Search and list public emails for a newsletter. No authentication required.
     */
    get: operations["list_public_emails"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * Collection 
     * @description A group of data that can be exported in an export. 
     * @enum {string}
     */
    ExportCollection: "subscribers" | "emails" | "events" | "referrals" | "surveys" | "comments" | "requests" | "mentions" | "conversations" | "images" | "stripe_subscriptions" | "stripe_products" | "stripe_customers" | "stripe_prices" | "stripe_charges";
    /**
     * Format 
     * @description An enumeration. 
     * @enum {string}
     */
    ExportFormat: "csv" | "json";
    /**
     * Status 
     * @description Represents the status of an export.
     * 
     * No action is required to move from one state or another; Buttondown
     * internally handles the transitions, and exposing the status is for
     * observability purposes only. 
     * @enum {string}
     */
    ExportStatus: "error" | "in_progress" | "not_started" | "ready";
    /**
     * Export 
     * @description Some software applications may want programmatic access to their newsletter exports.
     * This assists with a few niche use cases, such as regular backups or data ingestion
     * (into a data warehouse), or post-publishing processes that hinge on email events.
     * 
     * In general, you probably won't _need_ to use this endpoint unless you
     * _absolutely_ need to use this endpoint.
     * 
     * To browse the contents of a given export collection, refer to the [Data exports](https://docs.buttondown.com/data-exports-subscriber) section
     * of the documentation.
     */
    Export: {
      /** @description The [collections](https://docs.buttondown.com/api-exports-collections) of objects to export. */
      collections: (components["schemas"]["ExportCollection"])[];
      /**
       * Parameters 
       * @description Parameters to pass to the exporter. These are specific to the collection and format, and constrain the export.
       */
      parameters?: Record<string, unknown>;
      /**
       * @description The [format](https://docs.buttondown.com/api-exports-format) of the export files. 
       * @default csv
       */
      format?: components["schemas"]["ExportFormat"];
      /**
       * Columns 
       * @description If provided, the export will only include these columns.
       */
      columns?: (string)[];
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Url 
       * @description The URL of the export file. This is only available after the export has completed.
       */
      url?: string;
      /**
       * Completion Date 
       * Format: date-time 
       * @description The date and time the export completed.
       */
      completion_date?: string;
      /** @description The status of the export. */
      status: components["schemas"]["ExportStatus"];
    };
    /** ErrorMessage */
    ErrorMessage: {
      /** Code */
      code?: Record<string, unknown>;
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /**
     * CreateExportErrorCode 
     * @description An enumeration. 
     * @enum {string}
     */
    CreateExportErrorCode: "collection_empty_invalid" | "columns_empty_invalid" | "columns_invalid";
    /** ErrorMessage[CreateExportErrorCode] */
    ErrorMessage_CreateExportErrorCode_: {
      code: components["schemas"]["CreateExportErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** ExportInput */
    ExportInput: {
      /** @description The [collections](https://docs.buttondown.com/api-exports-collections) of objects to export. */
      collections: (components["schemas"]["ExportCollection"])[];
      /**
       * Parameters 
       * @description Parameters to pass to the exporter. These are specific to the collection and format, and constrain the export.
       */
      parameters?: Record<string, unknown>;
      /**
       * @description The [format](https://docs.buttondown.com/api-exports-format) of the export files. 
       * @default csv
       */
      format?: components["schemas"]["ExportFormat"];
      /**
       * Columns 
       * @description If provided, the export will only include these columns.
       */
      columns?: (string)[];
    };
    /** Page[Export] */
    ExportPage: {
      /** Results */
      results: (components["schemas"]["Export"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Tag 
     * @description Tags are a way to organize your subscribers. You can create, update, and
     * delete tags via the API. You can also list all tags for a given newsletter.
     * 
     * Tags don't have any strict functionality on their own, but you can send emails
     * to subscribers with a given tag (or to all subscribers _without_ a given tag.)
     */
    Tag: {
      /**
       * Name 
       * @example VIP
       */
      name: string;
      /**
       * Color 
       * @example #FFD700
       */
      color: string;
      /** Description */
      description?: string;
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /** Secondary Id */
      secondary_id: number;
    };
    /** TagInput */
    TagInput: {
      /**
       * Name 
       * @example VIP
       */
      name: string;
      /**
       * Color 
       * @example #FFD700
       */
      color: string;
      /** Description */
      description?: string;
    };
    /** Page[Tag] */
    TagPage: {
      /** Results */
      results: (components["schemas"]["Tag"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * UpdateTagErrorCode 
     * @description A potential error code that can be returned when updating a tag. 
     * @enum {string}
     */
    UpdateTagErrorCode: "name_already_exists" | "name_too_long";
    /** ErrorMessage[UpdateTagErrorCode] */
    ErrorMessage_UpdateTagErrorCode_: {
      code: components["schemas"]["UpdateTagErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** TagUpdateInput */
    TagUpdateInput: {
      /**
       * Name 
       * @example VIP
       */
      name?: string;
      /**
       * Color 
       * @example #FFD700
       */
      color?: string;
      /** Description */
      description?: string;
      /** Secondary Id */
      secondary_id?: number;
    };
    /** TagAnalytics */
    TagAnalytics: {
      /** Created Subscribers */
      created_subscribers: number;
      /** Click Rate */
      click_rate: number;
      /** Open Rate */
      open_rate: number;
    };
    /** Empty */
    Empty: Record<string, unknown>;
    /** Account */
    Account: {
      /** Username */
      username: string;
      /** Email Address */
      email_address: string;
    };
    /**
     * Image 
     * @description Images are, well, images! Buttondown allows you to upload images to its secure
     * S3 bucket and do with them what you will. This is sort of an odd duck of an
     * API, to be sure, but if you want to be able to do things like draft
     * and send emails completely on your iPad you need a surefire way of creating images.
     */
    Image: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Image 
       * @description The URL of the image. 
       * @example https://placecats.com/408/287
       */
      image: string;
    };
    /** Page[Image] */
    ImagePage: {
      /** Results */
      results: (components["schemas"]["Image"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Attachment 
     * @description Attachments are files that can be included with your emails. Buttondown allows
     * you to upload attachments to its secure S3 bucket and attach them to your emails.
     * Supported file types include documents, images, audio files, and more.
     */
    Attachment: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Name 
       * @description The name of the attachment. 
       * @example newsletter-guide.pdf
       */
      name: string;
      /**
       * File 
       * @description The URL of the attachment file. 
       * @example https://buttondown.s3.amazonaws.com/attachments/newsletter-guide.pdf
       */
      file: string;
      /**
       * Size 
       * @description The size of the attachment in bytes. 
       * @example 1000
       */
      size: number;
    };
    /** Page[Attachment] */
    AttachmentPage: {
      /** Results */
      results: (components["schemas"]["Attachment"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** Book */
    Book: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Title 
       * @description The title of the book.
       */
      title: string;
      /**
       * Url 
       * @description The URL where the book can be purchased or viewed.
       */
      url?: string;
      /**
       * Image Url 
       * @description The URL of the book's cover image.
       */
      image_url?: string;
      /**
       * Description 
       * @description A description of the book.
       */
      description?: string;
      /**
       * Year 
       * @description The year the book was published.
       */
      year?: number;
      /**
       * Isbn 
       * @description The ISBN of the book.
       */
      isbn?: string;
    };
    /** BookInput */
    BookInput: {
      /**
       * Title 
       * @description The title of the book.
       */
      title: string;
      /**
       * Url 
       * @description The URL where the book can be purchased or viewed.
       */
      url?: string;
      /**
       * Image Url 
       * @description The URL of the book's cover image.
       */
      image_url?: string;
      /**
       * Description 
       * @description A description of the book.
       */
      description?: string;
      /**
       * Year 
       * @description The year the book was published.
       */
      year?: number;
      /**
       * Isbn 
       * @description The ISBN of the book.
       */
      isbn?: string;
    };
    /** Page[Book] */
    BookPage: {
      /** Results */
      results: (components["schemas"]["Book"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** BookUpdateInput */
    BookUpdateInput: {
      /**
       * Title 
       * @description The title of the book.
       */
      title?: string;
      /**
       * Url 
       * @description The URL where the book can be purchased or viewed.
       */
      url?: string;
      /**
       * Image Url 
       * @description The URL of the book's cover image.
       */
      image_url?: string;
      /**
       * Description 
       * @description A description of the book.
       */
      description?: string;
      /**
       * Year 
       * @description The year the book was published.
       */
      year?: number;
      /**
       * Isbn 
       * @description The ISBN of the book.
       */
      isbn?: string;
    };
    /**
     * FailureBreakdownItem 
     * @description A single failure reason with its count.
     */
    FailureBreakdownItem: {
      /**
       * Code 
       * @description The failure reason code (e.g. 'hard_bounce', 'spam')
       */
      code: string;
      /**
       * Count 
       * @description Number of failures with this reason
       */
      count: number;
    };
    /** Analytics */
    Analytics: {
      /**
       * Recipients 
       * @default 0
       */
      recipients?: number;
      /**
       * Deliveries 
       * @default 0
       */
      deliveries?: number;
      /**
       * Opens 
       * @default 0
       */
      opens?: number;
      /**
       * Clicks 
       * @default 0
       */
      clicks?: number;
      /**
       * Temporary Failures 
       * @default 0
       */
      temporary_failures?: number;
      /**
       * Permanent Failures 
       * @default 0
       */
      permanent_failures?: number;
      /**
       * Unsubscriptions 
       * @default 0
       */
      unsubscriptions?: number;
      /**
       * Complaints 
       * @default 0
       */
      complaints?: number;
      /**
       * Survey Responses 
       * @default 0
       */
      survey_responses?: number;
      /**
       * Webmentions 
       * @default 0
       */
      webmentions?: number;
      /**
       * Page Views Lifetime 
       * @default 0
       */
      page_views_lifetime?: number;
      /**
       * Page Views 30 
       * @default 0
       */
      page_views_30?: number;
      /**
       * Page Views 7 
       * @default 0
       */
      page_views_7?: number;
      /**
       * Subscriptions 
       * @default 0
       */
      subscriptions?: number;
      /**
       * Paid Subscriptions 
       * @default 0
       */
      paid_subscriptions?: number;
      /**
       * Replies 
       * @default 0
       */
      replies?: number;
      /**
       * Comments 
       * @default 0
       */
      comments?: number;
      /**
       * Social Mentions 
       * @default 0
       */
      social_mentions?: number;
      /**
       * Temporary Failure Breakdown 
       * @description Breakdown of temporary failures, sorted by count descending
       */
      temporary_failure_breakdown?: (components["schemas"]["FailureBreakdownItem"])[];
      /**
       * Permanent Failure Breakdown 
       * @description Breakdown of permanent failures, sorted by count descending
       */
      permanent_failure_breakdown?: (components["schemas"]["FailureBreakdownItem"])[];
    };
    /**
     * CommentingMode 
     * @description Governs who can comment on this email.
     * 
     * This enum replaces the `is_comments_disabled` field, which has been deprecated. (Also note that this field may be superseded by newsletter-level settings; for instance, "enabled" is an invalid and inert value if the newsletter itself has comments disabled.) 
     * @enum {string}
     */
    EmailCommentingMode: "disabled" | "enabled" | "enabled_for_paid_subscribers";
    /**
     * Type 
     * @description Represents the audience of an email, and to whom it is visible both in the initial
     * email and in online archives. 
     * @enum {string}
     */
    EmailType: "public" | "private" | "premium" | "free" | "churned" | "archival";
    /**
     * Operator 
     * @description An enumeration. 
     * @enum {string}
     */
    Operator: "equals" | "not_equals" | "contains" | "not_contains" | "is_empty" | "is_not_empty" | "greater_than" | "less_than";
    /**
     * Filter 
     * @description A filter is a single condition that can be evaluated against a [Subscriber](/api-subscribers-retrieve). It has a field, an operator, and a value:
     * 
     * ```json
     * {
     *     "field": "subscriber.tags",
     *     "operator": "contains",
     *     "value": "executive"
     * }
     * ```
     * 
     * The field is the path to the field on the subscriber to evaluate. The operator is the operator to use when evaluating the filter. The value is the value to compare the field to.
     */
    Filter: {
      /** Field */
      field: string;
      operator: components["schemas"]["Operator"];
      /** Value */
      value: string;
    };
    /**
     * FilterGroup 
     * @description Buttondown's filtering schema can be used for multiple things:
     * 
     * - Filtering [the audience of an email](/api-emails-create) to a specific subset
     * - Creating [finely-tuned automations](/api-automation-introduction)
     * 
     * Filters are fractal; they can be nested in groups, and groups can be nested in other groups. This is accomplished through a tree-like structure. Every "FilterGroup" has a "predicate" field, which is either "and" or "or", which determines how the filters and groups within the group are combined, a "groups" field, which is a list of "FilterGroup" objects (that's that recursive bit!), and a "filters" field, which are the leaf-level filters themselves.
     * 
     * Let's say you want a simple filter: all subscribers who have a tag called "executive". You can do that like this:
     * 
     * ```json
     * {
     *     "filters": [{"field": "subscriber.tags", "operator": "contains", "value": "executive"}],
     *     "groups": [],
     *     "predicate": "and"
     * }
     * ```
     * 
     * Now, let's say you want to filter for subscribers who have a tag called "executive" and a tag called "general-electric". You can do that like this:
     * 
     * ```json
     * {
     *     "filters": [{"field": "subscriber.tags", "operator": "contains", "value": "executive"}, {"field": "subscriber.tags", "operator": "contains", "value": "general-electric"}],
     *     "groups": [],
     *     "predicate": "and"
     * }
     * ```
     * 
     * If you wanted to change that `and` to an `or`, you can do that like this:
     * 
     * ```json
     * {
     *     "filters": [{"field": "subscriber.tags", "operator": "contains", "value": "executive"}, {"field": "subscriber.tags", "operator": "contains", "value": "general-electric"}],
     *     "groups": [],
     *     "predicate": "or"
     * }
     * ```
     * 
     * Now, let's say you want to filter for subscribers who have a tag called "executive" _or_ a tag called "general-electric" and a tag called "admin". This is where the whole nested thing comes in handy. You can do that like this:
     * 
     * ```json
     * {
     *     "filters": [{"field": "subscriber.tags", "operator": "contains", "value": "executive"}],
     *     "groups": [
     *         {
     *             "filters": [{"field": "subscriber.tags", "operator": "contains", "value": "admin"}, {"field": "subscriber.tags", "operator": "contains", "value": "general-electric"}],
     *             "groups": [],
     *             "predicate": "and"
     *         }
     *     ],
     *     "predicate": "or"
     * }
     * ```
     * 
     * You can read more about the specific filter construction in the [Filter documentation](/api-emails-filter).
     */
    FilterGroup: {
      /**
       * Filters 
       * @description The leaf-level filters to apply to the audience.
       */
      filters: (components["schemas"]["Filter"])[];
      /**
       * Groups 
       * @description The nested groups to apply to the audience.
       */
      groups: (components["schemas"]["FilterGroup"])[];
      /**
       * Predicate 
       * @description The logical operator to use when combining filters (either 'and' or 'or'). 
       * @enum {string}
       */
      predicate: "and" | "or";
    };
    /**
     * Source 
     * @description Represents the original provenance of an email. This value is not exposed
     * to subscribers, but does determine some behavior of the email (e.g. whether
     * or not analytics can be calculated.) 
     * @enum {string}
     */
    EmailSource: "api" | "import" | "app" | "external_feed";
    /**
     * Status 
     * @description Represents the state of an email.
     * 
     * No action is required to move from one state or another; Buttondown
     * internally handles the transitions, and exposing the status is for
     * observability purposes only. 
     * @enum {string}
     */
    EmailStatus: "draft" | "managed_by_rss" | "about_to_send" | "scheduled" | "in_flight" | "paused" | "deleted" | "errored" | "sent" | "imported" | "throttled" | "resending" | "transactional" | "suppressed";
    /**
     * SuppressionReason 
     * @description Represents the reason an email was suppressed. 
     * @enum {string}
     */
    EmailSuppressionReason: "law_enforcement" | "internal_auditing";
    /**
     * EmailTemplate 
     * @description Represents the template of an email.
     * 
     * Each template has a different layout/style; you can view screenshots and examples [in the docs](https://docs.buttondown.com/customizing-email-design#buttondowns-default-templates). 
     * @enum {string}
     */
    NewsletterEmailTemplate: "classic" | "modern" | "plaintext" | "naked";
    /**
     * Email 
     * @description Emails are why you're here on Buttondown, right?
     * Creating an email via the API is just like creating one in the interface;
     * it will instantly trigger sending actual emails,
     * based on the tags and email type you provide.
     * 
     * Relevant changes to the schema:
     * 
     * - [2024-08-15](https://docs.buttondown.com/api-changelog-2024-08-15): unshipped the `included_tags` and `excluded_tags` fields.
     * - [2024-12-30](https://docs.buttondown.com/api-changelog-2024-12-30): unshipped the `is_comments_disabled` field, and replaced it with a more flexible `commenting_mode` field.
     * - [2025-09-23](https://docs.buttondown.com/api-changelog-2025-09-23): increased the maximum length of the `subject` field from 1000 to 2000 characters.
     */
    Email: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /** Absolute Url */
      absolute_url: string;
      analytics?: components["schemas"]["Analytics"];
      /**
       * Attachments 
       * @description A list of attachment IDs present on the email. (See [Attachments](https://docs.buttondown.com/api-attachments-introduction) for more information.)
       */
      attachments?: (string)[];
      /**
       * Body 
       * @description The body of the email, in either HTML or markdown format. Buttondown attempts to intelligently detect the format of the body automatically, but you can also specify the format explicitly by prepending the text with the `buttondown-editor-mode` comment: `<!-- buttondown-editor-mode: fancy -->` or `<!-- buttondown-editor-mode: plaintext -->`.
       */
      body: string;
      /**
       * Canonical Url 
       * @description The URL of the original source of the content.
       */
      canonical_url: string;
      commenting_mode: components["schemas"]["EmailCommentingMode"];
      /**
       * Description 
       * @description A human-readable description of the email, used for archives and SEO.
       */
      description: string;
      /** @default public */
      email_type?: components["schemas"]["EmailType"];
      /**
       * Featured 
       * @description Designated whether or not this email should be highlighted within the archives.
       */
      featured: boolean;
      filters: components["schemas"]["FilterGroup"];
      /**
       * Image 
       * @description A primary image to be used when previewing the email on the web or in other contexts.
       */
      image: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @default {}
       */
      metadata?: Record<string, unknown>;
      /**
       * Modification Date 
       * Format: date-time 
       * @description The date and time at which the object was last modified.
       */
      modification_date: string;
      /**
       * Publish Date 
       * Format: date-time 
       * @description The date and time at which the email should be published in the future (for scheduled emails), or the date and time at which the email was published (for sent emails).
       */
      publish_date?: string;
      /**
       * Related Email Ids 
       * @description A list of email IDs that are related to this email. Related emails are shown at the bottom of the email and archive pages.
       */
      related_email_ids: (string)[];
      /**
       * Secondary Id 
       * @description An informal 'number' for the email, used in some templates ('This was issue #123').
       */
      secondary_id?: number;
      /**
       * Should Trigger Pay Per Email Billing 
       * @description Whether this email should trigger pay-per-email billing for paid subscribers. Use this to differentiate between free updates and premium newsletters.
       */
      should_trigger_pay_per_email_billing: boolean;
      /**
       * Slug 
       * @description A short, human-readable identifier for the email. (Used in the URL of the email, and in the 'slug' field of the email object.) 
       * @example welcome-to-the-newsletter
       */
      slug?: string;
      /**
       * @description The source of the email. 
       * @example app
       */
      source: components["schemas"]["EmailSource"];
      /**
       * @description The current status of the email. 
       * @example draft
       */
      status: components["schemas"]["EmailStatus"];
      /**
       * Subject 
       * @description The subject line for the email.
       */
      subject: string;
      /** @description Reason for suppression, if email is suppressed. */
      suppression_reason?: components["schemas"]["EmailSuppressionReason"];
      /** @description If present, this template overrides your newsletter's default template. */
      template?: components["schemas"]["NewsletterEmailTemplate"];
    };
    /**
     * EmailCreationErrorCode 
     * @description Represents the type of error that occurred when creating an email.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    EmailCreationErrorCode: "subject_invalid" | "email_duplicate" | "email_invalid" | "body_invalid" | "publish_date_invalid" | "publish_date_missing" | "status_invalid" | "slug_invalid" | "canonical_url_invalid" | "tag_invalid";
    /** ErrorMessage[EmailCreationErrorCode] */
    ErrorMessage_EmailCreationErrorCode_: {
      code: components["schemas"]["EmailCreationErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** EmailInput */
    EmailInput: {
      /**
       * Attachments 
       * @default []
       */
      attachments?: (string)[];
      /**
       * Publish Date 
       * Format: date-time
       */
      publish_date?: string;
      /**
       * Subject 
       * @example The subject line for the email
       */
      subject: string;
      /** Slug */
      slug?: string;
      /**
       * Description 
       * @default
       */
      description?: string;
      /**
       * Canonical Url 
       * @default
       */
      canonical_url?: string;
      /**
       * Image 
       * @default
       */
      image?: string;
      /**
       * Body 
       * @description The body of the email, in either HTML or markdown format. Buttondown attempts to intelligently detect the format of the body automatically, but you can also specify the format explicitly by prepending the text with the `buttondown-editor-mode` comment: `<!-- buttondown-editor-mode: fancy -->` or `<!-- buttondown-editor-mode: plaintext -->`. 
       * @default  
       * @example This is an example of the body of an email.
       */
      body?: string;
      /** @default public */
      email_type?: components["schemas"]["EmailType"];
      /** @default about_to_send */
      status?: components["schemas"]["EmailStatus"];
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @default {}
       */
      metadata?: Record<string, unknown>;
      /** Secondary Id */
      secondary_id?: number;
      /**
       * Filters 
       * @default {
       *   "filters": [],
       *   "groups": [],
       *   "predicate": "and"
       * }
       */
      filters?: components["schemas"]["FilterGroup"];
      /** @default enabled */
      commenting_mode?: components["schemas"]["EmailCommentingMode"];
      /**
       * Related Email Ids 
       * @default []
       */
      related_email_ids?: (string)[];
      /**
       * Featured 
       * @description Designated whether or not this email should be highlighted within the archives. 
       * @default false
       */
      featured?: boolean;
      /**
       * Should Trigger Pay Per Email Billing 
       * @description Whether this email should trigger pay-per-email billing for paid subscribers. Use this to differentiate between free updates and premium newsletters. 
       * @default false
       */
      should_trigger_pay_per_email_billing?: boolean;
    };
    /** Page[Email] */
    EmailPage: {
      /** Results */
      results: (components["schemas"]["Email"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * EmailListErrorCode 
     * @description Represents the type of error that occurred when listing emails.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    EmailListErrorCode: "creation_date_invalid" | "publish_date_invalid";
    /** ErrorMessage[EmailListErrorCode] */
    ErrorMessage_EmailListErrorCode_: {
      code: components["schemas"]["EmailListErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** EmailUpdateInput */
    EmailUpdateInput: {
      /**
       * Attachments 
       * @description A list of attachment IDs present on the email. (See [Attachments](https://docs.buttondown.com/api-attachments-introduction) for more information.)
       */
      attachments?: (string)[];
      /** Publish Date */
      publish_date?: string | "none";
      /**
       * Subject 
       * @description The subject line for the email. 
       * @example The subject line for the email
       */
      subject?: string;
      /**
       * Description 
       * @description A human-readable description of the email, used for archives and SEO.
       */
      description?: string;
      /**
       * Canonical Url 
       * @description The URL of the original source of the content. 
       * @example https://sheinhardtwig.com/2025/01/17/our-nbc-partnership
       */
      canonical_url?: string;
      /**
       * Body 
       * @description The body of the email, in either HTML or markdown format. Buttondown attempts to intelligently detect the format of the body automatically, but you can also specify the format explicitly by prepending the text with the `buttondown-editor-mode` comment: `<!-- buttondown-editor-mode: fancy -->` or `<!-- buttondown-editor-mode: plaintext -->`. 
       * @example This is an example of the body of an email.
       */
      body?: string;
      /** @description The type of email to create. Defaults to `PUBLIC`. */
      email_type?: components["schemas"]["EmailType"];
      status?: components["schemas"]["EmailStatus"];
      suppression_reason?: components["schemas"]["EmailSuppressionReason"];
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @default {}
       */
      metadata?: Record<string, unknown>;
      /**
       * Image 
       * @default
       */
      image?: string;
      /**
       * Slug 
       * @example hello-world
       */
      slug?: string;
      /** Secondary Id */
      secondary_id?: number;
      filters?: components["schemas"]["FilterGroup"];
      /** Template */
      template?: components["schemas"]["NewsletterEmailTemplate"] | "none";
      commenting_mode?: components["schemas"]["EmailCommentingMode"];
      /** Related Email Ids */
      related_email_ids?: (string)[];
      /**
       * Featured 
       * @description Designated whether or not this email should be highlighted within the archives.
       */
      featured?: boolean;
      /**
       * Should Trigger Pay Per Email Billing 
       * @description Whether this email should trigger pay-per-email billing for paid subscribers. Use this to differentiate between free updates and premium newsletters.
       */
      should_trigger_pay_per_email_billing?: boolean;
    };
    /**
     * AccessLevel 
     * @description An enumeration. 
     * @enum {string}
     */
    AccessLevel: "none" | "read" | "write";
    /** Permissions */
    Permissions: {
      /** @default none */
      subscriber?: components["schemas"]["AccessLevel"];
      /** @default none */
      email?: components["schemas"]["AccessLevel"];
      /** @default none */
      sending?: components["schemas"]["AccessLevel"];
      /** @default none */
      styling?: components["schemas"]["AccessLevel"];
      /** @default none */
      administrivia?: components["schemas"]["AccessLevel"];
      /** @default none */
      automations?: components["schemas"]["AccessLevel"];
      /** @default none */
      surveys?: components["schemas"]["AccessLevel"];
      /** @default none */
      forms?: components["schemas"]["AccessLevel"];
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    InvitationStatus: "pending" | "accepted" | "declined" | "revoked" | "owner";
    /** User */
    User: {
      permissions: components["schemas"]["Permissions"];
      /** Email Address */
      email_address: string;
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      status: components["schemas"]["InvitationStatus"];
      /**
       * Last Logged In 
       * Format: date-time
       */
      last_logged_in?: string;
    };
    /** History */
    History: {
      /** History Id */
      history_id: number;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /** Value */
      value: string;
      /** User Id */
      user_id?: string;
      user?: components["schemas"]["User"];
    };
    /** Page[History] */
    HistoryPage: {
      /** Results */
      results: (components["schemas"]["History"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** Render */
    Render: {
      /**
       * Content 
       * @description The rendered HTML for the specified target format.
       */
      content: string;
    };
    /** SendDraftInput */
    SendDraftInput: {
      /**
       * Subscribers 
       * @description A list of subscriber ids to which to send the email. 
       * @example [
       *   "bc5601f4-b180-4e02-8501-c18080662376",
       *   "24ee3338-daaf-42b0-bf7b-0cab38972fe5"
       * ]
       */
      subscribers?: (string)[];
      /**
       * Recipients 
       * @description A list of email addresses to send the email to. 
       * @example [
       *   "telemachus@buttondown.email"
       * ]
       */
      recipients?: (string)[];
    };
    /**
     * Source 
     * @description Represents the original provenance of a subscriber. This value is not exposed
     * to subscribers; it's only used for internal tracking purposes and governs some
     * of the behavior of the subscriber (i.e. whether or not to require double
     * opt-in.) 
     * @enum {string}
     */
    SubscriberSource: "admin" | "api" | "carrd" | "comment" | "embedded_form" | "import" | "memberful" | "organic" | "patreon" | "stripe" | "user" | "zapier";
    /** StripeCoupon */
    StripeCoupon: {
      /** Coupon Id */
      coupon_id: string;
      /** Percent Off */
      percent_off?: string;
      /** Amount Off */
      amount_off?: number;
      /** Name */
      name?: string;
    };
    /**
     * Type 
     * @description Represents the state of a subscriber and what emails they
     * should or should not be receiving. This type is meant to be fully expressive
     * so as to consolidate the logic of determining what emails a subscriber should
     * receive into a single place.
     * 
     * Note that the only types that can be set programmatically are REGULAR, UNSUBSCRIBED,
     * GIFTED and UNPAID. All other types are meant to be user-visible and cannot
     * be set programmatically. 
     * @enum {string}
     */
    SubscriberType: "blocked" | "complained" | "churning" | "churned" | "gifted" | "unactivated" | "unpaid" | "undeliverable" | "premium" | "past_due" | "paused" | "regular" | "removed" | "trialed" | "unsubscribed" | "upcoming";
    /** Transition */
    Transition: {
      /**
       * Date 
       * Format: date-time
       */
      date: string;
      type: components["schemas"]["SubscriberType"];
    };
    /** EmailTransition */
    EmailTransition: {
      /**
       * Date 
       * Format: date-time
       */
      date: string;
      /** Old Email Address */
      old_email_address?: string;
      /** New Email Address */
      new_email_address: string;
    };
    /**
     * UndeliverabilityReason 
     * @description The reason Buttondown has marked the subscriber as undeliverable.
     * Undeliverable subscribers are not sent emails, and may be periodically removed from the system (or restored, if the reason is no longer valid.)
     * 
     * These reasons are grouped into three categories:
     * - PermanentFailure ("Failed (recipient)"): Address-based issues where the recipient is truly unreachable.
     *   Includes: HARD_BOUNCE
     * - MessageFailure ("Failed (message)"): Message/sender problems where future emails may succeed.
     *   Includes: ACCESS_DENIED, AUTHENTICATION_ISSUE, DELIVERY_EXPIRED, DOMAIN_BLOCKED, EMAIL_BLOCKED,
     *             IP_BLOCKED, ON_ESP_DENYLIST, OUT_OF_STORAGE, PROBLEMATIC_URL, SPAM
     * - Deferral (not shown to customers): Transient delivery issues that will be retried.
     *   Includes: RATE_LIMITED, TRANSIENT 
     * @enum {string}
     */
    SubscriberUndeliverabilityReason: "access_denied" | "authentication_issue" | "delivery_expired" | "domain_blocked" | "email_blocked" | "hard_bounce" | "ip_blocked" | "ip_undeliverable" | "malformed" | "on_esp_denylist" | "other" | "out_of_storage" | "problematic_url" | "rate_limited" | "spam" | "transient" | "disabled" | "does_not_exist" | "spf_failed" | "unreachable";
    /**
     * Subscriber 
     * @description Subscribers are the main way you collect email addresses and
     * recipients on Buttondown. They're what you see on your
     * [subscribers page](https://buttondown.com/subscribers).
     * 
     * Relevant changes to the schema:
     * 
     * - [2024-08-01](https://docs.buttondown.com/api-changelog-2024-08-01): renamed `subscriber_type` and `email` to `type` and `email_address` respectively.
     * - [2024-07-13](https://docs.buttondown.com/api-changelog-2024-08-01): removed `external_url` in favor of `absolute_url`.
     */
    Subscriber: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /** Avatar Url */
      avatar_url?: string;
      /**
       * Churn Date 
       * Format: date-time
       */
      churn_date?: string;
      /**
       * Email Address 
       * @description The email address of the subscriber. 
       * @example telemachus@buttondown.email
       */
      email_address: string;
      /**
       * Gift Subscription Message 
       * @description A custom message that was sent to the subscriber when the gift subscription was created.
       */
      gift_subscription_message?: string;
      /** Ip Address */
      ip_address?: string;
      /**
       * Last Click Date 
       * Format: date-time
       */
      last_click_date?: string;
      /**
       * Last Open Date 
       * Format: date-time
       */
      last_open_date?: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @default {}
       */
      metadata?: Record<string, unknown>;
      /**
       * Notes 
       * @description Any notes you want to attach to the subscriber. These are not publicly visible. 
       * @default
       */
      notes?: string;
      /**
       * Purchased By 
       * @description The email address of the individual who purchased this subscription on behalf of the subscriber.
       */
      purchased_by?: string;
      /**
       * Purchased Message 
       * @description A custom message that was sent to the subscriber when the subscription was purchased on behalf of the subscriber.
       */
      purchased_message?: string;
      /** Referral Code */
      referral_code: string;
      /**
       * Referrer Url 
       * @default
       */
      referrer_url?: string;
      /**
       * Risk Score 
       * @description The risk score of the subscriber. Positive numbers represent a higher risk; negative numbers represent a lower risk.
       */
      risk_score?: number;
      /** Secondary Id */
      secondary_id: number;
      source: components["schemas"]["SubscriberSource"];
      stripe_coupon?: components["schemas"]["StripeCoupon"];
      /** Stripe Customer Id */
      stripe_customer_id?: string;
      /**
       * Subscriber Import Id 
       * Format: uuid
       */
      subscriber_import_id?: string;
      /** Tags */
      tags: (string)[];
      /**
       * Transitions 
       * @default []
       */
      transitions?: (components["schemas"]["Transition"])[];
      /**
       * Email Transitions 
       * @default []
       */
      email_transitions?: (components["schemas"]["EmailTransition"])[];
      type: components["schemas"]["SubscriberType"];
      /**
       * Undeliverability Date 
       * Format: date-time
       */
      undeliverability_date?: string;
      /** @description The reason the subscriber is undeliverable. (Only populated for undeliverable subscribers.) */
      undeliverability_reason?: components["schemas"]["SubscriberUndeliverabilityReason"];
      /**
       * Unsubscription Date 
       * Format: date-time
       */
      unsubscription_date?: string;
      /** Unsubscription Reason */
      unsubscription_reason?: string;
      /**
       * Upgrade Date 
       * Format: date-time
       */
      upgrade_date?: string;
      /** Utm Campaign */
      utm_campaign: string;
      /** Utm Medium */
      utm_medium: string;
      /** Utm Source */
      utm_source: string;
      /** Stripe Customer */
      stripe_customer?: Record<string, unknown>;
    };
    /**
     * ValidationErrorCode 
     * @description Represents the type of error that occurred when validating subscriber input.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    SubscriberInputValidationErrorCode: "email_already_exists" | "email_blocked" | "email_empty" | "email_invalid" | "ip_address_spammy" | "metadata_invalid" | "rate_limited" | "subscriber_already_exists" | "subscriber_blocked" | "subscriber_suppressed" | "tag_invalid";
    /** ErrorMessage[ValidationErrorCode] */
    ErrorMessage_ValidationErrorCode_: {
      code: components["schemas"]["SubscriberInputValidationErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** SubscriberInput */
    SubscriberInput: {
      /**
       * Email Address 
       * @description The email address of the subscriber. 
       * @example telemachus@buttondown.email
       */
      email_address: string;
      /**
       * Notes 
       * @description Any notes you want to attach to the subscriber. These are not publicly visible. 
       * @default
       */
      notes?: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @default {}
       */
      metadata?: Record<string, unknown>;
      /**
       * Tags 
       * @default []
       */
      tags?: (string)[];
      /**
       * Referrer Url 
       * @default
       */
      referrer_url?: string;
      /**
       * Utm Campaign 
       * @default
       */
      utm_campaign?: string;
      /**
       * Utm Medium 
       * @default
       */
      utm_medium?: string;
      /**
       * Utm Source 
       * @default
       */
      utm_source?: string;
      /**
       * Referring Subscriber Id 
       * Format: uuid 
       * @description The ID of the subscriber that referred this subscriber.
       */
      referring_subscriber_id?: string;
      /** @example regular */
      type?: components["schemas"]["SubscriberType"];
      /**
       * Ip Address 
       * @description The IP address of the subscriber. If provided, we will use this IP address to determine the subscriber's location and validate their legitimacy. 
       * @example 127.0.0.1
       */
      ip_address?: string;
    };
    /** Page[Subscriber] */
    SubscriberPage: {
      /** Results */
      results: (components["schemas"]["Subscriber"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * ListSubscribersErrorCode 
     * @description Represents the type of error that occurred when listing subscribers.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    ListSubscribersErrorCode: "invalid_tag" | "date_invalid" | "invalid_ordering";
    /** ErrorMessage[ListSubscribersErrorCode] */
    ErrorMessage_ListSubscribersErrorCode_: {
      code: components["schemas"]["ListSubscribersErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /**
     * UpdateSubscriberErrorCode 
     * @description Represents the type of error that occurred when updating a subscriber.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    UpdateSubscriberErrorCode: "email_already_exists" | "email_invalid" | "email_has_been_changed_too_many_times" | "firewall_blocked" | "subscriber_type_invalid" | "tag_invalid";
    /** ErrorMessage[UpdateSubscriberErrorCode] */
    ErrorMessage_UpdateSubscriberErrorCode_: {
      code: components["schemas"]["UpdateSubscriberErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** SubscriberUpdateInput */
    SubscriberUpdateInput: {
      /**
       * Email Address 
       * @description The email address of the subscriber. 
       * @example telemachus@buttondown.email
       */
      email_address?: string;
      /**
       * Notes 
       * @description Any notes you want to attach to the subscriber. These are not publicly visible. 
       * @example One of our first subscribers!
       */
      notes?: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @default {}
       */
      metadata?: Record<string, unknown>;
      /** Tags */
      tags?: (string)[];
      /**
       * Referrer Url 
       * @default
       */
      referrer_url?: string;
      type?: components["schemas"]["SubscriberType"];
      /** Unsubscription Reason */
      unsubscription_reason?: string;
      /**
       * Email Which Prompted Unsubscription Id 
       * Format: uuid
       */
      email_which_prompted_unsubscription_id?: string;
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    AutomationAttemptStatus: "unprocessed" | "processed" | "failed" | "pending" | "skipped";
    /** AutomationForSubscriber */
    AutomationForSubscriber: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /** Name */
      name: string;
      status: components["schemas"]["AutomationAttemptStatus"];
      /**
       * Automation Id 
       * Format: uuid
       */
      automation_id: string;
      /**
       * Execution Date 
       * Format: date-time
       */
      execution_date: string;
      /** Actions */
      actions: (Record<string, unknown>)[];
    };
    /** Page[AutomationForSubscriber] */
    AutomationForSubscriberPage: {
      /** Results */
      results: (components["schemas"]["AutomationForSubscriber"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * UpdateAutomationAttemptErrorCode 
     * @description Represents the type of error that occurred when updating an automation attempt.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    UpdateAutomationAttemptErrorCode: "automation_attempt_not_found" | "invalid_status";
    /** ErrorMessage[UpdateAutomationAttemptErrorCode] */
    ErrorMessage_UpdateAutomationAttemptErrorCode_: {
      code: components["schemas"]["UpdateAutomationAttemptErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** AutomationAttemptUpdateInput */
    AutomationAttemptUpdateInput: {
      /**
       * Status 
       * @description The status to set for the automation attempt. Only 'skipped' is allowed. 
       * @enum {string}
       */
      status: "skipped";
    };
    /** StripeSubscription */
    StripeSubscription: {
      /** Subscription Id */
      subscription_id: string;
      /** Url */
      url: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Ending Date 
       * Format: date-time
       */
      ending_date?: string;
      /** Amount */
      amount: number;
      /** Currency */
      currency: string;
      /** Cadence */
      cadence: string;
      /** Status */
      status: string;
      /**
       * Application Fee Percent 
       * @description The application fee percent for the subscription.
       */
      application_fee_percent?: number;
      /**
       * Source 
       * @description Buttondown attempts to detect the source of a subscription, but this is not always possible. 
       * @enum {string}
       */
      source?: "substack" | "buttondown";
      /**
       * Product 
       * @description The name of the product which the subscriber is subscribed to. (You can override this by setting the `buttondown_template_facing_id` metadata on the product in Stripe.)
       */
      product?: string;
    };
    /** Page[UnexpandableStripeSubscription] */
    StripeSubscriptionPage: {
      /** Results */
      results: (components["schemas"]["StripeSubscription"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * AuditingMode 
     * @description An enumeration. 
     * @enum {string}
     */
    NewsletterAuditingMode: "disabled" | "enabled" | "aggressive";
    /**
     * Newsletter 
     * @description You will likely not need to interact with your newsletter settings
     * programmatically, but if you do, this is the endpoint for you. You can
     * create, update, and list newsletters via the API; this is ideal for
     * integrating with Buttondown as a headless email or newsletter provider
     * (e.g. for a SaaS product.)
     */
    Newsletter: {
      /**
       * Api Key 
       * Format: uuid 
       * @description The API key for this newsletter, used for authenticating API requests.
       */
      api_key: string;
      /**
       * @description The auditing mode for your newsletter, which controls spam and abuse protection. See [the Firewall](https://docs.buttondown.com/firewall) for more information. 
       * @enum {unknown}
       */
      auditing_mode?: "disabled" | "enabled" | "aggressive";
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Css 
       * @description Custom CSS styling applied to your newsletter emails. See [CSS customization](https://docs.buttondown.com/customizing-email-design#adding-custom-css) for more information. 
       * @default
       */
      css?: string;
      /**
       * Css Tokens 
       * @description Custom CSS tokens (variables) for your newsletter. These can be referenced in your CSS and templates to maintain consistent styling. 
       * @default {}
       */
      css_tokens?: {
        [key: string]: string | undefined;
      };
      /**
       * Custom Churn Email Body 
       * @description Custom body content for the email sent when a paid subscriber cancels. Supports template tags like `{{ subscriber.email }}` and `{{ newsletter.name }}`. 
       * @default
       */
      custom_churn_email_body?: string;
      /**
       * Custom Churn Email Subject 
       * @description Custom subject line for the email sent when a paid subscriber cancels. Supports template tags like `{{ newsletter.name }}`. 
       * @default
       */
      custom_churn_email_subject?: string;
      /**
       * Custom Churn Email Template 
       * @description The email template to use for churn emails. If not set, uses the newsletter's default template.
       */
      custom_churn_email_template?: string;
      /**
       * Custom Email Template 
       * @description The identifier for a custom email template. See [email templates](https://docs.buttondown.com/customizing-email-design#buttondowns-default-templates) for available options.
       */
      custom_email_template?: string;
      /**
       * Description 
       * @description A brief description of your newsletter, displayed on your public archive page and used for SEO.
       */
      description: string;
      /**
       * Domain 
       * @description The custom domain where your newsletter archives are hosted (e.g., 'newsletter.example.com'). See [custom domains](https://docs.buttondown.com/hosting-on-a-custom-domain) for setup instructions. 
       * @default
       */
      domain?: string;
      /**
       * Email Address 
       * @description The 'From' email address used when sending your newsletter. Must be verified before use. 
       * @default
       */
      email_address?: string;
      /**
       * Email Domain 
       * @description The custom domain from which your newsletter emails are sent (e.g., 'mail.example.com'). See [sending domains](https://docs.buttondown.com/sending-from-a-custom-domain) for setup instructions. 
       * @default
       */
      email_domain?: string;
      /**
       * Enabled Features 
       * @description A list of features enabled for your newsletter. Common values include 'archives', 'portal', 'surveys', 'comments', 'paid_subscriptions', 'automations', 'webhooks', 'tracking', and 'referrals'. 
       * @default []
       */
      enabled_features?: (string)[];
      /**
       * Footer 
       * @description HTML content displayed at the bottom of your newsletter emails. Supports [template tags](https://docs.buttondown.com/template-tags). 
       * @default
       */
      footer?: string;
      /**
       * From Name 
       * @description The display name shown in the 'From' field of your emails (e.g., 'Jane from Acme Newsletter'). 
       * @default
       */
      from_name?: string;
      /**
       * Header 
       * @description HTML content displayed at the top of your newsletter emails. Supports [template tags](https://docs.buttondown.com/template-tags). 
       * @default
       */
      header?: string;
      /**
       * Icon 
       * @description URL to your newsletter's icon image, used as a favicon and in various UI contexts.
       */
      icon?: string;
      /**
       * Id 
       * Format: uuid 
       * @description The unique identifier for this newsletter.
       */
      id: string;
      /**
       * Image 
       * @description URL to your newsletter's header or branding image, displayed on archive pages and in social previews.
       */
      image?: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @default {}
       */
      metadata?: Record<string, unknown>;
      /**
       * Name 
       * @description The display name of your newsletter, shown to subscribers and on your archive page.
       */
      name: string;
      /**
       * Sort 
       * @description The default sorting method for listing subscribers or messages. Example values: 'creation_date', '-creation_date', 'email_address'. 
       * @default creation_date
       */
      sort?: string;
      /**
       * Test Mode 
       * @description Whether test mode is enabled. When enabled, emails are not actually sent to subscribers, useful for testing automations and workflows. 
       * @default false
       */
      test_mode?: boolean;
      /**
       * Tint Color 
       * @description The accent color for your newsletter, used in emails and on your archive page. Must be a valid hex color code. 
       * @default #0069FF
       */
      tint_color?: string;
      /**
       * Username 
       * @description The unique URL-safe identifier for your newsletter, used in your archive URL (e.g., 'buttondown.com/username').
       */
      username: string;
      /**
       * Web Css 
       * @description Custom CSS styling applied to your newsletter's web presence (archive pages, subscription forms, etc.). 
       * @default
       */
      web_css?: string;
    };
    /** Page[Newsletter] */
    NewsletterPage: {
      /** Results */
      results: (components["schemas"]["Newsletter"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * CreateNewsletterErrorCode 
     * @description Represents the type of error that occurred when creating a newsletter.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    CreateNewsletterErrorCode: "username_already_exists" | "username_malformed";
    /** ErrorMessage[CreateNewsletterErrorCode] */
    ErrorMessage_CreateNewsletterErrorCode_: {
      code: components["schemas"]["CreateNewsletterErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** NewsletterInput */
    NewsletterInput: {
      /**
       * @description The auditing mode for your newsletter, which controls spam and abuse protection. See [the Firewall](https://docs.buttondown.com/firewall) for more information. 
       * @example enabled
       */
      auditing_mode?: components["schemas"]["NewsletterAuditingMode"];
      /**
       * Css 
       * @description Custom CSS styling applied to your newsletter emails. See [CSS customization](https://docs.buttondown.com/customizing-email-design#adding-custom-css) for more information. 
       * @default  
       * @example .header { color: #000; }
       */
      css?: string;
      /**
       * Css Tokens 
       * @description Custom CSS tokens (variables) for your newsletter. These can be referenced in your CSS and templates to maintain consistent styling. 
       * @default {} 
       * @example {
       *   "primary-color": "#0069FF"
       * }
       */
      css_tokens?: {
        [key: string]: string | undefined;
      };
      /**
       * Custom Email Template 
       * @description The identifier for a custom email template. See [email templates](https://docs.buttondown.com/customizing-email-design#buttondowns-default-templates) for available options. 
       * @example modern
       */
      custom_email_template?: string;
      /**
       * Description 
       * @description A brief description of your newsletter, displayed on your public archive page and used for SEO. 
       * @example Stay up to date with the latest trends in wigs and hairpieces
       */
      description: string;
      /**
       * Domain 
       * @description The custom domain where your newsletter archives are hosted (e.g., 'newsletter.example.com'). See [custom domains](https://docs.buttondown.com/hosting-on-a-custom-domain) for setup instructions. 
       * @default  
       * @example sheinhardt.com
       */
      domain?: string;
      /**
       * Email Address 
       * @description The 'From' email address used when sending your newsletter. Must be verified before use. 
       * @example newsletter@sheinhardt.com
       */
      email_address?: string;
      /**
       * Email Domain 
       * @description The custom domain from which your newsletter emails are sent (e.g., 'mail.example.com'). See [sending domains](https://docs.buttondown.com/sending-from-a-custom-domain) for setup instructions. 
       * @default  
       * @example mail.sheinhardt.com
       */
      email_domain?: string;
      /**
       * Enabled Features 
       * @description A list of features enabled for your newsletter. Common values include 'archives', 'portal', 'surveys', 'comments', 'paid_subscriptions', 'automations', 'webhooks', 'tracking', and 'referrals'. 
       * @default [] 
       * @example [
       *   "archives",
       *   "portal",
       *   "surveys"
       * ]
       */
      enabled_features?: (string)[];
      /**
       * Footer 
       * @description HTML content displayed at the bottom of your newsletter emails. Supports [template tags](https://docs.buttondown.com/template-tags). 
       * @default  
       * @example <p>Thanks for reading!</p>
       */
      footer?: string;
      /**
       * From Name 
       * @description The display name shown in the 'From' field of your emails (e.g., 'Jane from Acme Newsletter'). 
       * @default  
       * @example Sheinhardt Wig Company
       */
      from_name?: string;
      /**
       * Header 
       * @description HTML content displayed at the top of your newsletter emails. Supports [template tags](https://docs.buttondown.com/template-tags). 
       * @default  
       * @example <p>Welcome to our newsletter!</p>
       */
      header?: string;
      /**
       * Icon 
       * @description URL to your newsletter's icon image, used as a favicon and in various UI contexts. 
       * @default  
       * @example https://example.com/icon.png
       */
      icon?: string;
      /**
       * Image 
       * @description URL to your newsletter's header or branding image, displayed on archive pages and in social previews. 
       * @default  
       * @example https://example.com/header.jpg
       */
      image?: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @default {}
       */
      metadata?: Record<string, unknown>;
      /**
       * Name 
       * @description The display name of your newsletter, shown to subscribers and on your archive page. 
       * @example Sheinhardt Wig Company
       */
      name: string;
      /**
       * Test Mode 
       * @description Whether test mode is enabled. When enabled, emails are not actually sent to subscribers, useful for testing automations and workflows.
       */
      test_mode?: boolean;
      /**
       * Tint Color 
       * @description The accent color for your newsletter, used in emails and on your archive page. Must be a valid hex color code. 
       * @default #0069FF 
       * @example #0069FF
       */
      tint_color?: string;
      /**
       * Username 
       * @description The unique URL-safe identifier for your newsletter, used in your archive URL (e.g., 'buttondown.com/username'). 
       * @example sheinhardt
       */
      username: string;
      /**
       * Web Css 
       * @description Custom CSS styling applied to your newsletter's web presence (archive pages, subscription forms, etc.). 
       * @default  
       * @example .container { max-width: 800px; }
       */
      web_css?: string;
    };
    /** NewsletterUpdateInput */
    NewsletterUpdateInput: {
      /**
       * @description The auditing mode for your newsletter, which controls spam and abuse protection. See [the Firewall](https://docs.buttondown.com/firewall) for more information. 
       * @example enabled
       */
      auditing_mode?: components["schemas"]["NewsletterAuditingMode"];
      /**
       * Css 
       * @description Custom CSS styling applied to your newsletter emails. See [CSS customization](https://docs.buttondown.com/customizing-email-design#adding-custom-css) for more information. 
       * @example .header { color: #000; }
       */
      css?: string;
      /**
       * Css Tokens 
       * @description Custom CSS tokens (variables) for your newsletter. These can be referenced in your CSS and templates to maintain consistent styling. 
       * @example {
       *   "primary-color": "#0069FF"
       * }
       */
      css_tokens?: {
        [key: string]: string | undefined;
      };
      /**
       * Custom Churn Email Body 
       * @description Custom body content for the email sent when a paid subscriber cancels. Supports template tags like `{{ subscriber.email }}` and `{{ newsletter.name }}`. 
       * @example Hi {{ subscriber.email }},
       * 
       * We're sorry to see you go!
       */
      custom_churn_email_body?: string;
      /**
       * Custom Churn Email Subject 
       * @description Custom subject line for the email sent when a paid subscriber cancels. Supports template tags like `{{ newsletter.name }}`. 
       * @example You've canceled your premium subscription to {{ newsletter.name }}
       */
      custom_churn_email_subject?: string;
      /**
       * Custom Churn Email Template 
       * @description The email template to use for churn emails. If not set, uses the newsletter's default template. 
       * @example modern
       */
      custom_churn_email_template?: string;
      /**
       * Custom Email Template 
       * @description The identifier for a custom email template. See [email templates](https://docs.buttondown.com/customizing-email-design#buttondowns-default-templates) for available options. 
       * @example modern
       */
      custom_email_template?: string;
      /**
       * Description 
       * @description A brief description of your newsletter, displayed on your public archive page and used for SEO. 
       * @example Stay up to date with the latest trends in wigs and hairpieces
       */
      description?: string;
      /**
       * Domain 
       * @description The custom domain where your newsletter archives are hosted (e.g., 'newsletter.example.com'). See [custom domains](https://docs.buttondown.com/hosting-on-a-custom-domain) for setup instructions. 
       * @example sheinhardt.com
       */
      domain?: string;
      /**
       * Email Address 
       * @description The 'From' email address used when sending your newsletter. Must be verified before use. 
       * @example newsletter@sheinhardt.com
       */
      email_address?: string;
      /**
       * Email Domain 
       * @description The custom domain from which your newsletter emails are sent (e.g., 'mail.example.com'). See [sending domains](https://docs.buttondown.com/sending-from-a-custom-domain) for setup instructions. 
       * @example mail.sheinhardt.com
       */
      email_domain?: string;
      /**
       * Enabled Features 
       * @description A list of features enabled for your newsletter. Common values include 'archives', 'portal', 'surveys', 'comments', 'paid_subscriptions', 'automations', 'webhooks', 'tracking', and 'referrals'. 
       * @example [
       *   "archives",
       *   "portal",
       *   "surveys"
       * ]
       */
      enabled_features?: (string)[];
      /**
       * Footer 
       * @description HTML content displayed at the bottom of your newsletter emails. Supports [template tags](https://docs.buttondown.com/template-tags). 
       * @example <p>Thanks for reading!</p>
       */
      footer?: string;
      /**
       * From Name 
       * @description The display name shown in the 'From' field of your emails (e.g., 'Jane from Acme Newsletter'). 
       * @example Sheinhardt Wig Company
       */
      from_name?: string;
      /**
       * Header 
       * @description HTML content displayed at the top of your newsletter emails. Supports [template tags](https://docs.buttondown.com/template-tags). 
       * @example <p>Welcome to our newsletter!</p>
       */
      header?: string;
      /**
       * Icon 
       * @description URL to your newsletter's icon image, used as a favicon and in various UI contexts. 
       * @example https://example.com/icon.png
       */
      icon?: string;
      /**
       * Image 
       * @description URL to your newsletter's header or branding image, displayed on archive pages and in social previews. 
       * @example https://example.com/header.jpg
       */
      image?: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @example {
       *   "source": "my-app",
       *   "tier": "pro"
       * }
       */
      metadata?: Record<string, unknown>;
      /**
       * Name 
       * @description The display name of your newsletter, shown to subscribers and on your archive page. 
       * @example Sheinhardt Wig Company
       */
      name?: string;
      /**
       * Test Mode 
       * @description Whether test mode is enabled. When enabled, emails are not actually sent to subscribers, useful for testing automations and workflows.
       */
      test_mode?: boolean;
      /**
       * Tint Color 
       * @description The accent color for your newsletter, used in emails and on your archive page. Must be a valid hex color code. 
       * @example #0069FF
       */
      tint_color?: string;
      /**
       * Username 
       * @description The unique URL-safe identifier for your newsletter, used in your archive URL (e.g., 'buttondown.com/username'). 
       * @example sheinhardt
       */
      username?: string;
      /**
       * Web Css 
       * @description Custom CSS styling applied to your newsletter's web presence (archive pages, subscription forms, etc.). 
       * @example .container { max-width: 800px; }
       */
      web_css?: string;
    };
    /**
     * Type 
     * @description Represents the action being performed on a bulk of objects.
     * 
     * (Not to be coy, but these names should be self-explanatory.) 
     * @enum {string}
     */
    BulkActionType: "add_notes" | "apply_tags" | "apply_metadata" | "rename_metadata" | "ban_subscribers" | "delete_subscribers" | "gift_subscribers" | "ungift_subscribers" | "reactivate_subscribers" | "mark_subscribers_as_not_spammy" | "resubscribe_subscribers" | "send_emails" | "unban_subscribers" | "send_reminders" | "unsubscribe_subscribers" | "delete_emails" | "update_email_types" | "update_archival_modes" | "update_commenting_modes" | "mark_inbox_items_read" | "delete_inbox_items" | "delete_tags" | "change_tags_colors" | "delete_surveys" | "delete_survey_responses" | "replay_events" | "delete_comments" | "update_survey_statuses" | "modify_stripe_subscriptions";
    /**
     * Status 
     * @description Represents the status of a bulk action.
     * 
     * No action is required to move from one state or another; Buttondown
     * internally handles the transitions, and exposing the status is for
     * observability purposes only. 
     * @enum {string}
     */
    BulkActionStatus: "not_started" | "in_progress" | "processed" | "failed";
    /**
     * BulkAction 
     * @description A bulk action represents, well, a bulk action. It is used to perform
     * actions on a large number of objects at once. For example, you can
     * use it to delete a large number of emails, or to unsubscribe a large
     * number of subscribers. The actions within a bulk action are processed
     * serially by Buttondown; this should be considered an ergonomic way to
     * batch API calls across the network rather than a net-new piece of functionality
     * in of itself.
     */
    BulkAction: {
      /**
       * @description The type of bulk action to perform. 
       * @example delete_emails
       */
      type: components["schemas"]["BulkActionType"];
      /**
       * Metadata 
       * @example {
       *   "ids": [
       *     "611c8825-6f21-4544-bb47-9f50453e9cb0",
       *     "418c701a-efe3-4e3d-a404-e635a2f28775"
       *   ]
       * }
       */
      metadata: {
        [key: string]: (string | (string)[] | Record<string, unknown>) | undefined;
      };
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      status: components["schemas"]["BulkActionStatus"];
      /**
       * Completion Date 
       * Format: date-time 
       * @description The date and time at which the bulk action was completed.
       */
      completion_date?: string;
    };
    /** BulkActionInput */
    BulkActionInput: {
      /**
       * @description The type of bulk action to perform. 
       * @example delete_emails
       */
      type: components["schemas"]["BulkActionType"];
      /**
       * Metadata 
       * @example {
       *   "ids": [
       *     "611c8825-6f21-4544-bb47-9f50453e9cb0",
       *     "418c701a-efe3-4e3d-a404-e635a2f28775"
       *   ]
       * }
       */
      metadata: {
        [key: string]: (string | (string)[] | Record<string, unknown>) | undefined;
      };
    };
    /**
     * Status 
     * @description Represents the status of the automation, and whether or not it is active. Inactive automations will not be processed. Deleted automations will not be processed. 
     * @enum {string}
     */
    ExternalFeedAutomationStatus: "active" | "failing" | "inactive" | "deleted";
    /**
     * Behavior 
     * @description An enumeration. 
     * @enum {string}
     */
    ExternalFeedAutomationBehavior: "draft" | "emails";
    /**
     * Cadence 
     * @description An enumeration. 
     * @enum {string}
     */
    ExternalFeedAutomationCadence: "every" | "daily" | "weekly" | "monthly";
    /**
     * ExternalFeed 
     * @description An automation is a one-to-one mapping between an external RSS feed and an action
     * to be performed when new items are detected in that feed. Right now, Buttondown offers
     * two actions:
     * 
     * - Send an email
     * - Create an email but save it as a draft to be sent out manually
     * 
     * The automation is configured with a cadence, which is the frequency at which the
     * automation will be run. The cadence can be one of the following:
     * 
     * - Run the automation every time a new item is detected in the feed
     * - Run the automation once per week
     * - Run the automation once per month
     */
    ExternalFeed: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Last Checked Date 
       * Format: date-time
       */
      last_checked_date?: string;
      status: components["schemas"]["ExternalFeedAutomationStatus"];
      behavior: components["schemas"]["ExternalFeedAutomationBehavior"];
      cadence: components["schemas"]["ExternalFeedAutomationCadence"];
      /** Cadence Metadata */
      cadence_metadata: {
        [key: string]: string | undefined;
      };
      filters: components["schemas"]["FilterGroup"];
      /** Url */
      url: string;
      /** Subject */
      subject: string;
      /** Body */
      body: string;
      /** Label */
      label: string;
      /**
       * Metadata 
       * @description Metadata to be passed to emails rendered by this RSS feed. 
       * @example {
       *   "foo": "bar"
       * }
       */
      metadata?: Record<string, unknown>;
      /**
       * Skip Old Items 
       * @description Skip items with publish date older than one day from when they're discovered
       */
      skip_old_items: boolean;
    };
    /** ExternalFeedInput */
    ExternalFeedInput: {
      /**
       * Url 
       * @description The URL of the RSS feed to poll for new items. 
       * @example http://lorem-rss.herokuapp.com/feed
       */
      url: string;
      /**
       * @description The [behavior](https://docs.buttondown.com/api-external-feed-behavior) of the external feed. 
       * @example draft
       */
      behavior: components["schemas"]["ExternalFeedAutomationBehavior"];
      /** @example daily */
      cadence: components["schemas"]["ExternalFeedAutomationCadence"];
      /** Cadence Metadata */
      cadence_metadata: {
        [key: string]: string | undefined;
      };
      filters: components["schemas"]["FilterGroup"];
      /** Subject */
      subject: string;
      /** Body */
      body: string;
      /**
       * Label 
       * @default
       */
      label?: string;
      /**
       * Metadata 
       * @description Metadata to be passed to emails rendered by this RSS feed. 
       * @example {
       *   "foo": "bar"
       * }
       */
      metadata?: Record<string, unknown>;
      /**
       * Skip Old Items 
       * @description Skip items with publish date older than one day from when they're discovered 
       * @default false
       */
      skip_old_items?: boolean;
    };
    /** Page[ExternalFeed] */
    ExternalFeedPage: {
      /** Results */
      results: (components["schemas"]["ExternalFeed"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** ExternalFeedUpdateInput */
    ExternalFeedUpdateInput: {
      /** @example draft */
      behavior?: components["schemas"]["ExternalFeedAutomationBehavior"];
      /** @example daily */
      cadence?: components["schemas"]["ExternalFeedAutomationCadence"];
      /** Cadence Metadata */
      cadence_metadata?: {
        [key: string]: string | undefined;
      };
      filters?: components["schemas"]["FilterGroup"];
      /** Subject */
      subject?: string;
      /** Body */
      body?: string;
      /** Label */
      label?: string;
      status?: components["schemas"]["ExternalFeedAutomationStatus"];
      /**
       * Metadata 
       * @description Metadata to be passed to emails rendered by this RSS feed. 
       * @example {
       *   "foo": "bar"
       * }
       */
      metadata?: Record<string, unknown>;
      /**
       * Skip Old Items 
       * @description Skip items with publish date older than one day from when they're discovered
       */
      skip_old_items?: boolean;
    };
    /**
     * Status 
     * @description The status of a given item (meaning a distinct URL) within an RSS feed. 
     * @enum {string}
     */
    ExternalFeedItemStatus: "unprocessed" | "irrelevant" | "errored" | "skipped" | "queued" | "processed";
    /**
     * ExternalFeedItem 
     * @description An external feed item is a single item in an external RSS feed. It is created
     * automatically by Buttondown when a new item is detected in an external feed. External feed
     * items are immutable and cannot be modified or deleted.
     */
    ExternalFeedItem: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      status: components["schemas"]["ExternalFeedItemStatus"];
      /** Url */
      url: string;
      /**
       * Publish Date 
       * Format: date-time
       */
      publish_date: string;
      /** Title */
      title: string;
      /** Description */
      description: string;
      /** Content */
      content: string;
      /** Author */
      author: string;
      /** Email Id */
      email_id?: string;
      email?: components["schemas"]["Email"];
    };
    /** Page[ExternalFeedItem] */
    ExternalFeedItemPage: {
      /** Results */
      results: (components["schemas"]["ExternalFeedItem"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    AutomationStatus: "active" | "inactive";
    /**
     * Type 
     * @description Various types of events that are recorded by Buttondown, both in terms of exogenous systems
     * like Stripe and Memberful, and endogenous ones like email opens and clicks. (In general, if anything
     * important ever happens that could be relevant to your newsletter, we have an event type for it!)
     * 
     * These event types power lots of things within Buttondown. They're used to trigger automations, webhooks,
     * and analytics.
     * 
     * (Note that Buttondown also has a different thing we call "events"; those are `EmailEvents` and are used
     * for tracking aggregate details about an email. Alas, we shouldn't have used the term "event" for two different
     * things, but it's too late to go back now!)
     * 
     * In general, our event namespacing tries to hew to the following pattern:
     * 
     * <source>.<object>.<action>
     * 
     * When wondering which object we are referring to, default to the _more granular_ object.
     * 
     * For instance, an email being sent to a subscriber is `subscriber.delivered`, not `email.sent`. 
     * @enum {string}
     */
    ExternalEventType: "advertising_slot.purchased" | "automation.invoked" | "date.day.started" | "date.month.started" | "date.week.started" | "date.year.started" | "email.created" | "email.deleted" | "email.sent" | "email.status.changed" | "email.updated" | "external_feed_item.created" | "export.completed" | "export.created" | "export.failed" | "firewall.blocked" | "mention.created" | "memberful.member.updated" | "memberful.subscription.created" | "memberful.subscription.deleted" | "note.created" | "note.deleted" | "patreon.member.updated" | "patreon.membership.created" | "patreon.membership.deleted" | "shopify.customer.created" | "shopify.customer.updated" | "social_mention.created" | "stripe.checkout.session.completed" | "stripe.customer.updated" | "stripe.subscription.activated" | "stripe.subscription.churning" | "stripe.subscription.deactivated" | "subscriber.bounced" | "subscriber.changed_email" | "subscriber.churned" | "subscriber.clicked" | "subscriber.commented" | "subscriber.complained" | "subscriber.confirmed" | "subscriber.created" | "subscriber.deleted" | "subscriber.delivered" | "subscriber.opened" | "subscriber.paid" | "subscriber.paused" | "subscriber.resumed" | "subscriber.referred" | "subscriber.referred.paid" | "subscriber.rejected" | "subscriber.replied" | "subscriber.responded_to_survey" | "subscriber.tags.changed" | "subscriber.trial_ended" | "subscriber.trial_started" | "subscriber.type.changed" | "subscriber.unsubscribed" | "subscriber.updated" | "subscriber.viewed_checkout_page" | "survey.cleared_responses" | "survey.created" | "survey.deleted" | "survey.updated" | "form.created" | "form.deleted" | "form.updated";
    /** Delay */
    Delay: {
      /** Value */
      value: string;
      /**
       * Unit 
       * @enum {string}
       */
      unit: "minutes" | "hours" | "days" | "weeks";
      /**
       * Time Of Day 
       * @enum {string}
       */
      time_of_day?: "morning" | "evening" | "";
    };
    /** Timing */
    Timing: {
      /**
       * Time 
       * @enum {string}
       */
      time: "immediate" | "delay";
      delay?: components["schemas"]["Delay"];
    };
    /**
     * ActionType 
     * @description The action that is triggered when the automation is successfully run. 
     * @enum {string}
     */
    AutomationActionType: "add_tags" | "remove_tags" | "send_email" | "add_metadata" | "change_email_address" | "gift_premium_subscription" | "ungift_premium_subscription" | "send_discord_invitation" | "send_github_invitation" | "create_subscriber" | "unsubscribe_subscriber" | "shopify_unsubscribe" | "shopify_resubscribe" | "shopify_set_tags" | "shopify_create_customer" | "send_notification" | "forward_reply" | "create_linkedin_post" | "create_twitter_post" | "create_tumblr_post" | "create_bluesky_post" | "create_arena_post" | "create_export" | "send_post_request" | "send_confirmation_reminder";
    /** Action */
    Action: {
      type: components["schemas"]["AutomationActionType"];
      /** Metadata */
      metadata: Record<string, unknown>;
    };
    /** Automation */
    Automation: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /** Name */
      name: string;
      status: components["schemas"]["AutomationStatus"];
      trigger: components["schemas"]["ExternalEventType"];
      timing: components["schemas"]["Timing"];
      /** Actions */
      actions: (components["schemas"]["Action"])[];
      filters: components["schemas"]["FilterGroup"];
      /** Metadata */
      metadata: Record<string, unknown>;
    };
    /** Page[Automation] */
    AutomationPage: {
      /** Results */
      results: (components["schemas"]["Automation"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * AutomationCreationErrorCode 
     * @description Represents the type of error that occurred when creating an automation.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    AutomationCreationErrorCode: "delay_invalid" | "filter_invalid__tag" | "filter_invalid" | "action_invalid" | "invalid_newsletter_id" | "action_invalid__missing_body_or_subject";
    /** ErrorMessage[AutomationCreationErrorCode] */
    ErrorMessage_AutomationCreationErrorCode_: {
      code: components["schemas"]["AutomationCreationErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** AutomationInput */
    AutomationInput: {
      /** Name */
      name: string;
      trigger: components["schemas"]["ExternalEventType"];
      timing: components["schemas"]["Timing"];
      /** Actions */
      actions: (Record<string, unknown>)[];
      filters: components["schemas"]["FilterGroup"];
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** AutomationUpdateInput */
    AutomationUpdateInput: {
      /** Name */
      name?: string;
      status?: components["schemas"]["AutomationStatus"];
      trigger?: components["schemas"]["ExternalEventType"];
      timing?: components["schemas"]["Timing"];
      /** Actions */
      actions?: (Record<string, unknown>)[];
      filters?: components["schemas"]["FilterGroup"];
      /** Metadata */
      metadata?: Record<string, unknown>;
    };
    /**
     * Failure 
     * @description An enumeration. 
     * @enum {string}
     */
    Failure: "email_already_exists";
    /** ErrorMessage[Failure] */
    ErrorMessage_Failure_: {
      code: components["schemas"]["Failure"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** UserInput */
    UserInput: {
      permissions: components["schemas"]["Permissions"];
      /** Email Address */
      email_address: string;
    };
    /** Page[User] */
    UserPage: {
      /** Results */
      results: (components["schemas"]["User"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** UserUpdateInput */
    UserUpdateInput: {
      /** Permissions */
      permissions: {
        [key: string]: string | undefined;
      };
    };
    /** Product */
    Product: {
      /** Id */
      id: string;
      /** Product Id */
      product_id: string;
      /** Name */
      name: string;
      /** Creation Date */
      creation_date: string;
      /** Active */
      active: boolean;
      /** Default Price */
      default_price?: string;
    };
    /** Price */
    Price: {
      /** Amount */
      amount?: number;
      /**
       * Cadence 
       * @enum {string}
       */
      cadence: "year" | "month" | "one-time" | "email" | "week";
      /** Currency */
      currency: string;
      /** Description */
      description?: string;
      /** Maximum Amount */
      maximum_amount?: number;
      /** Minimum Amount */
      minimum_amount?: number;
      /** Product Id */
      product_id?: string;
      /**
       * Style 
       * @enum {string}
       */
      style: "pay-what-you-want" | "fixed" | "usage-based";
      /** Suggested Amount */
      suggested_amount?: number;
      /** Id */
      id: string;
      product?: components["schemas"]["Product"];
    };
    /** Page[Price] */
    PricePage: {
      /** Results */
      results: (components["schemas"]["Price"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * ListPricesErrorCode 
     * @description Represents the type of error that occurred when listing a price.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    ListPricesErrorCode: "paid_subscriptions_uninitialized";
    /** ErrorMessage[ListPricesErrorCode] */
    ErrorMessage_ListPricesErrorCode_: {
      code: components["schemas"]["ListPricesErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /**
     * CreatePriceErrorCode 
     * @description Represents the type of error that occurred when listing a price.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    CreatePriceErrorCode: "invalid_amount" | "maximum_amount_too_high" | "paid_subscriptions_uninitialized" | "product_deleted" | "suggested_amount_out_of_range";
    /** ErrorMessage[CreatePriceErrorCode] */
    ErrorMessage_CreatePriceErrorCode_: {
      code: components["schemas"]["CreatePriceErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** PriceInput */
    PriceInput: {
      /** Amount */
      amount?: number;
      /**
       * Cadence 
       * @enum {string}
       */
      cadence: "year" | "month" | "one-time" | "email" | "week";
      /** Currency */
      currency: string;
      /** Description */
      description?: string;
      /** Maximum Amount */
      maximum_amount?: number;
      /** Minimum Amount */
      minimum_amount?: number;
      /** Product Id */
      product_id?: string;
      /**
       * Style 
       * @enum {string}
       */
      style: "pay-what-you-want" | "fixed" | "usage-based";
      /** Suggested Amount */
      suggested_amount?: number;
    };
    /** Page[StripeCoupon] */
    StripeCouponPage: {
      /** Results */
      results: (components["schemas"]["StripeCoupon"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * ResponseCadence 
     * @description An enumeration. 
     * @enum {string}
     */
    SurveyResponseCadence: "once" | "once_per_email";
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    SurveyStatus: "active" | "inactive";
    /**
     * InputType 
     * @description An enumeration. 
     * @enum {string}
     */
    SurveyInputType: "radio" | "checkbox" | "text";
    /** Survey */
    Survey: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /** Identifier */
      identifier: string;
      /** Question */
      question: string;
      /** Response Count */
      response_count: number;
      /** Answers */
      answers: (string)[];
      /** Notes */
      notes: string;
      /** Randomize Answers */
      randomize_answers: boolean;
      response_cadence: components["schemas"]["SurveyResponseCadence"];
      status: components["schemas"]["SurveyStatus"];
      /** Is Freeform Response Enabled */
      is_freeform_response_enabled: boolean;
      input_type: components["schemas"]["SurveyInputType"];
    };
    /**
     * CreateSurveyErrorCode 
     * @description Represents the type of error that occurred when creating a survey.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    CreateSurveyErrorCode: "identifier_already_exists" | "not_enough_answers";
    /** ErrorMessage[CreateSurveyErrorCode] */
    ErrorMessage_CreateSurveyErrorCode_: {
      code: components["schemas"]["CreateSurveyErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** SurveyInput */
    SurveyInput: {
      /**
       * Identifier 
       * @example color
       */
      identifier: string;
      /**
       * Question 
       * @example What's your favorite color?
       */
      question: string;
      /**
       * Answers 
       * @example [
       *   "Red",
       *   "Green",
       *   "Blue"
       * ]
       */
      answers: (string)[];
      /**
       * Notes 
       * @default  
       * @example
       */
      notes?: string;
      /**
       * Is Freeform Response Enabled 
       * @default false 
       * @example false
       */
      is_freeform_response_enabled?: boolean;
      /**
       * @default radio 
       * @example radio
       */
      input_type?: components["schemas"]["SurveyInputType"];
      /**
       * Randomize Answers 
       * @default false 
       * @example false
       */
      randomize_answers?: boolean;
      /**
       * @default once 
       * @example once
       */
      response_cadence?: components["schemas"]["SurveyResponseCadence"];
    };
    /** Page[Survey] */
    SurveyPage: {
      /** Results */
      results: (components["schemas"]["Survey"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * UpdateSurveyErrorCode 
     * @description An enumeration. 
     * @enum {string}
     */
    UpdateSurveyErrorCode: "answers_empty" | "not_enough_answers" | "survey_has_responses";
    /** ErrorMessage[UpdateSurveyErrorCode] */
    ErrorMessage_UpdateSurveyErrorCode_: {
      code: components["schemas"]["UpdateSurveyErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** SurveyUpdateInput */
    SurveyUpdateInput: {
      /** Notes */
      notes?: string;
      /**
       * Answers 
       * @example [
       *   "Red",
       *   "Green",
       *   "Blue"
       * ]
       */
      answers?: (string)[];
      /** @example once */
      response_cadence?: components["schemas"]["SurveyResponseCadence"];
      status?: components["schemas"]["SurveyStatus"];
      /**
       * Is Freeform Response Enabled 
       * @default false
       */
      is_freeform_response_enabled?: boolean;
      input_type?: components["schemas"]["SurveyInputType"];
      /** Randomize Answers */
      randomize_answers?: boolean;
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    FormStatus: "active" | "inactive";
    /** Form */
    Form: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /** Title */
      title: string;
      /** Slug */
      slug: string;
      /** Body */
      body: string;
      /** Css */
      css: string;
      /** Success Body */
      success_body: string;
      /** Surveys */
      surveys: (string)[];
      /** Admin */
      admin: boolean;
      status: components["schemas"]["FormStatus"];
    };
    /**
     * CreateFormErrorCode 
     * @description Represents the type of error that occurred when creating a form.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    CreateFormErrorCode: "slug_already_exists";
    /** ErrorMessage[CreateFormErrorCode] */
    ErrorMessage_CreateFormErrorCode_: {
      code: components["schemas"]["CreateFormErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** FormInput */
    FormInput: {
      /**
       * Title 
       * @example Contact Form
       */
      title: string;
      /**
       * Slug 
       * @example contact
       */
      slug: string;
      /**
       * Body 
       * @default  
       * @example
       */
      body?: string;
      /**
       * Css 
       * @default  
       * @example
       */
      css?: string;
      /**
       * Success Body 
       * @default  
       * @example Thank you for your submission!
       */
      success_body?: string;
      /**
       * Surveys 
       * @example []
       */
      surveys?: (string)[];
      /**
       * Admin 
       * @default false 
       * @example false
       */
      admin?: boolean;
      /**
       * @default active 
       * @example active
       */
      status?: components["schemas"]["FormStatus"];
    };
    /** Page[Form] */
    FormPage: {
      /** Results */
      results: (components["schemas"]["Form"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** FormUpdateInput */
    FormUpdateInput: {
      /** Title */
      title?: string;
      /** Slug */
      slug?: string;
      /** Body */
      body?: string;
      /** Css */
      css?: string;
      /** Success Body */
      success_body?: string;
      /** Surveys */
      surveys?: (string)[];
      /** Admin */
      admin?: boolean;
      status?: components["schemas"]["FormStatus"];
    };
    /**
     * Source 
     * @description An enumeration. 
     * @enum {string}
     */
    APIRequestSource: "api" | "app" | "carrd" | "zapier" | "cli" | "make";
    /**
     * APIRequestDetail 
     * @description Represents a request to the API (api.buttondown.com).
     */
    APIRequestDetail: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /** Status Code */
      status_code: number;
      /** Path */
      path: string;
      /** Method */
      method: string;
      source: components["schemas"]["APIRequestSource"];
      /**
       * Version 
       * @enum {string}
       */
      version: "2024-07-01" | "2024-08-01" | "2024-08-15" | "2024-09-30" | "2024-12-30" | "2025-01-02" | "2025-05-19" | "2025-06-01" | "2026-01-01";
      /** Ip Address */
      ip_address: string;
      /** Request Data */
      request_data: string;
      /** Response Data */
      response_data: string;
      /** Headers */
      headers: {
        [key: string]: string | undefined;
      };
    };
    /**
     * APIRequest 
     * @description Represents a request to the API (api.buttondown.com).
     */
    APIRequest: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /** Status Code */
      status_code: number;
      /** Path */
      path: string;
      /** Method */
      method: string;
      source: components["schemas"]["APIRequestSource"];
      /**
       * Version 
       * @enum {string}
       */
      version: "2024-07-01" | "2024-08-01" | "2024-08-15" | "2024-09-30" | "2024-12-30" | "2025-01-02" | "2025-05-19" | "2025-06-01" | "2026-01-01";
      /** Ip Address */
      ip_address: string;
    };
    /** APIRequestList */
    APIRequestList: {
      /** Results */
      results: (components["schemas"]["APIRequest"])[];
      /** Cursor */
      cursor?: string;
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    AdvertisingSKUStatus: "active" | "inactive";
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    AdvertisingSlotStatus: "expired" | "executed" | "finalized" | "open" | "sold";
    /** AdvertisingSlot */
    AdvertisingSlot: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Date 
       * Format: date
       */
      date: string;
      status: components["schemas"]["AdvertisingSlotStatus"];
      /** Invoice Url */
      invoice_url?: string;
      /** Sku Id */
      sku_id: string;
      /** Submission Url */
      submission_url: string;
      /** Sponsor Company */
      sponsor_company: string;
      /** Sponsor Email */
      sponsor_email: string;
      /** Sponsor Name */
      sponsor_name: string;
      /** Content */
      content: string;
      /** Content Image Id */
      content_image_id?: string;
      /** Content Url */
      content_url: string;
      /**
       * Content Approved At 
       * Format: date-time
       */
      content_approved_at?: string;
      /**
       * Content Rejected At 
       * Format: date-time
       */
      content_rejected_at?: string;
      /** Content Rejection Reason */
      content_rejection_reason: string;
      /**
       * Content Submitted At 
       * Format: date-time
       */
      content_submitted_at?: string;
    };
    /** AdvertisingUnit */
    AdvertisingUnit: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      status: components["schemas"]["AdvertisingSKUStatus"];
      /** Slots */
      slots: (components["schemas"]["AdvertisingSlot"])[];
      /** Title */
      title: string;
      /** Description */
      description: string;
      /** Behavior */
      behavior: string;
      /** Url */
      url: string;
      /** Price */
      price?: number;
      /** Allows Html */
      allows_html: boolean;
      /** Allows Image */
      allows_image: boolean;
      /** Max Characters */
      max_characters?: number;
      /** Submission Deadline Days */
      submission_deadline_days: number;
    };
    /** Page[AdvertisingUnit] */
    AdvertisingUnitPage: {
      /** Results */
      results: (components["schemas"]["AdvertisingUnit"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** AdvertisingUnitInput */
    AdvertisingUnitInput: {
      /** Title */
      title?: string;
      /** Description */
      description?: string;
      /**
       * Behavior 
       * @default
       */
      behavior?: string;
      /**
       * Url 
       * @default
       */
      url?: string;
      /** Price */
      price?: number;
    };
    /** AdvertisingUnitUpdateInput */
    AdvertisingUnitUpdateInput: {
      /** Title */
      title?: string;
      /** Description */
      description?: string;
      /** Dates */
      dates: (string)[];
      /** Behavior */
      behavior?: string;
      /** Url */
      url?: string;
      /** Price */
      price?: number;
      /** Allows Html */
      allows_html?: boolean;
      /** Allows Image */
      allows_image?: boolean;
      /** Max Characters */
      max_characters?: number;
      /** Submission Deadline Days */
      submission_deadline_days?: number;
    };
    /** Page[AdvertisingSlot] */
    AdvertisingSlotPage: {
      /** Results */
      results: (components["schemas"]["AdvertisingSlot"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** AdvertisingSlotUpdateInput */
    AdvertisingSlotUpdateInput: {
      /** Content */
      content?: string;
      /**
       * Content Approved At 
       * Format: date-time
       */
      content_approved_at?: string;
      /** Content Image Id */
      content_image_id?: string;
      /** Content Rejection Reason */
      content_rejection_reason?: string;
      /** Content Url */
      content_url?: string;
      /** Sponsor Company */
      sponsor_company?: string;
      /** Sponsor Email */
      sponsor_email?: string;
      /** Sponsor Name */
      sponsor_name?: string;
      /**
       * Status 
       * @enum {string}
       */
      status?: "approve" | "reject";
    };
    /**
     * WebhookStatus 
     * @description The status of a webhook. 
     * @enum {string}
     */
    WebhookStatus: "enabled" | "disabled";
    /**
     * Webhook 
     * @description Webhooks are used to notify external services of events that occur in the
     * system. For example, when a newsletter is sent, a webhook can be used to
     * notify an external service that the newsletter has been sent.
     */
    Webhook: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * @description Whether the webhook is enabled or not. 
       * @default enabled 
       * @example enabled
       */
      status?: components["schemas"]["WebhookStatus"];
      /**
       * @description The types of event for which the webhook will be triggered. 
       * @example [
       *   "email.created",
       *   "email.sent"
       * ]
       */
      event_types: (components["schemas"]["ExternalEventType"])[];
      /**
       * Url 
       * Format: uri 
       * @description The URL to which the webhook will send POST requests. 
       * @example https://my.api/webhook
       */
      url: string;
      /**
       * Description 
       * @description An optional description of the webhook, for reference. 
       * @default  
       * @example Trigger when an email is created to notify in Slack.
       */
      description?: string;
      /**
       * Signing Key 
       * @description Optional HMAC signing key for webhook verification. When set, webhook requests will include an X-Buttondown-Signature header with sha256=<signature>. 
       * @default  
       * @example
       */
      signing_key?: string;
    };
    /** WebhookInput */
    WebhookInput: {
      /**
       * @description Whether the webhook is enabled or not. 
       * @default enabled 
       * @example enabled
       */
      status?: components["schemas"]["WebhookStatus"];
      /**
       * @description The types of event for which the webhook will be triggered. 
       * @example [
       *   "email.created",
       *   "email.sent"
       * ]
       */
      event_types: (components["schemas"]["ExternalEventType"])[];
      /**
       * Url 
       * Format: uri 
       * @description The URL to which the webhook will send POST requests. 
       * @example https://my.api/webhook
       */
      url: string;
      /**
       * Description 
       * @description An optional description of the webhook, for reference. 
       * @default  
       * @example Trigger when an email is created to notify in Slack.
       */
      description?: string;
      /**
       * Signing Key 
       * @description Optional HMAC signing key for webhook verification. When set, webhook requests will include an X-Buttondown-Signature header with sha256=<signature>. 
       * @default  
       * @example
       */
      signing_key?: string;
    };
    /** Page[Webhook] */
    WebhookPage: {
      /** Results */
      results: (components["schemas"]["Webhook"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    WebhookAttemptStatus: "unattempted" | "successful" | "failed";
    /** WebhookAttemptOutput */
    WebhookAttemptOutput: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * @description The status of the webhook attempt. 
       * @example successful
       */
      status: components["schemas"]["WebhookAttemptStatus"];
    };
    /** Page[WebhookAttemptOutput] */
    WebhookAttemptOutputPage: {
      /** Results */
      results: (components["schemas"]["WebhookAttemptOutput"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Type 
     * @description An enumeration. 
     * @enum {string}
     */
    CommentType: "reviewer" | "subscriber";
    /**
     * Comment 
     * @description Comments are a way for subscribers to interact with newsletters. They're a way to
     * provide feedback, ask questions, and generally engage with the content of an email.
     * Comments exist in a tree structure; comments that reply to other comments are
     * considered "children" of the parent comment.
     */
    Comment: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /** Email Id */
      email_id: string;
      /** Subscriber Id */
      subscriber_id?: string;
      /**
       * Parent Id 
       * @description The ID of the parent comment, if this comment is a reply to another comment.
       */
      parent_id?: string;
      /** Text */
      text: string;
      comment_type: components["schemas"]["CommentType"];
      /** Annotation Data */
      annotation_data?: Record<string, unknown>;
      subscriber?: components["schemas"]["Subscriber"];
      email?: components["schemas"]["Email"];
    };
    /** CommentInput */
    CommentInput: {
      /**
       * Text 
       * @description The text content of the comment
       */
      text: string;
      /**
       * Parent Id 
       * @description The ID of the parent comment, if this comment is a reply to another comment.
       */
      parent_id?: string;
      /**
       * Email Id 
       * @description The ID of the email this comment is for. Required if parent_id is not provided.
       */
      email_id?: string;
    };
    /** Page[Comment] */
    CommentPage: {
      /** Results */
      results: (components["schemas"]["Comment"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** Response */
    Response: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Answer 
       * @description The answer given to the survey.
       */
      answer: string;
      /**
       * Text 
       * @description Optional text included by the subscriber with the response. Subscribers are only prompted to supply a text response if the `is_freeform_response_enabled` field is set to `true` on the survey.
       */
      text: string;
      /** Survey Id */
      survey_id: string;
      /** Subscriber Id */
      subscriber_id: string;
      /** Email Id */
      email_id?: string;
      /** Automation Id */
      automation_id?: string;
      subscriber?: components["schemas"]["Subscriber"];
      survey?: components["schemas"]["Survey"];
      email?: components["schemas"]["Email"];
      automation?: components["schemas"]["Automation"];
    };
    /** Page[Response] */
    ResponsePage: {
      /** Results */
      results: (components["schemas"]["Response"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** ResponseInput */
    ResponseInput: {
      /** Subscriber Id */
      subscriber_id: string;
      /** Survey Id */
      survey_id: string;
      /** Email Id */
      email_id: string;
      /** Answer */
      answer: number;
    };
    /** ResponseUpdateInput */
    ResponseUpdateInput: {
      /**
       * Text 
       * @description The text response to update. Only applicable if the survey has freeform responses enabled.
       */
      text?: string;
    };
    /**
     * EmailEventType 
     * @description An enumeration. 
     * @enum {string}
     */
    EmailEventType: "activation_bounced" | "activation_clicked" | "activation_complained" | "activation_deferred" | "activation_delivered" | "activation_opened" | "activation_rejected" | "activation_reminder_bounced" | "activation_reminder_clicked" | "activation_reminder_complained" | "activation_reminder_deferred" | "activation_reminder_delivered" | "activation_reminder_opened" | "activation_reminder_rejected" | "subscription_confirmed_clicked" | "subscription_confirmed_bounced" | "subscription_confirmed_complained" | "subscription_confirmed_deferred" | "subscription_confirmed_delivered" | "subscription_confirmed_opened" | "subscription_confirmed_rejected" | "attempted" | "bounced" | "clicked" | "complained" | "deferred" | "delivered" | "opened" | "rejected" | "replied" | "sent" | "unsubscribed";
    /** EmailEvent */
    EmailEvent: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /** Subscriber Id */
      subscriber_id?: string;
      /** Email Id */
      email_id?: string;
      /** Automation Id */
      automation_id?: string;
      /** Metadata */
      metadata: {
        [key: string]: string | undefined;
      };
      event_type: components["schemas"]["EmailEventType"];
      subscriber?: components["schemas"]["Subscriber"];
      email?: components["schemas"]["Email"];
      automation?: components["schemas"]["Automation"];
    };
    /** Page[EmailEvent] */
    EmailEventPage: {
      /** Results */
      results: (components["schemas"]["EmailEvent"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** Note */
    Note: {
      /**
       * Id 
       * @description A unique TypeID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Body 
       * @description The text content of the note. 
       * @example This subscriber upgraded to a paid plan.
       */
      body: string;
      /**
       * Model Type 
       * @description The type of object this note is attached to (e.g., 'email', 'subscriber'). 
       * @example email 
       * @enum {string}
       */
      model_type: "email" | "subscriber" | "external_feed" | "automation" | "survey" | "stripe_customer" | "tag" | "comment" | "conversation" | "webmention" | "socialmention";
      /**
       * Model Id 
       * @description The ID of the object this note is attached to. 
       * @example 13121cd6-0dfc-424c-bb12-988b0a32fcb3
       */
      model_id: string;
      /** Metadata */
      metadata: Record<string, unknown>;
      /**
       * Source 
       * @description The source of the note. If the note was created by a Buttondown admin, this will be 'admin'; otherwise, it will be 'user'. 
       * @example admin 
       * @enum {string}
       */
      source: "admin" | "user";
      /** User Id */
      user_id?: string;
      user?: components["schemas"]["User"];
    };
    /** NoteInput */
    NoteInput: {
      /**
       * Body 
       * @description The text content of the note. 
       * @example This subscriber upgraded to a paid plan.
       */
      body: string;
      /**
       * Model Type 
       * @description The type of object this note is attached to (e.g., 'email', 'subscriber'). 
       * @example email 
       * @enum {string}
       */
      model_type: "email" | "subscriber" | "external_feed" | "automation" | "survey" | "stripe_customer" | "tag" | "comment" | "conversation" | "webmention" | "socialmention";
      /**
       * Model Id 
       * @description The ID of the object this note is attached to. 
       * @example 13121cd6-0dfc-424c-bb12-988b0a32fcb3
       */
      model_id: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. Metadata can be nested — you can store objects and arrays within your metadata. (You can [read more about metadata.](https://docs.buttondown.com/metadata)) 
       * @default {}
       */
      metadata?: Record<string, unknown>;
    };
    /** Page[Note] */
    NotePage: {
      /** Results */
      results: (components["schemas"]["Note"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * PublicEmail 
     * @description Public email schema for email search results.
     */
    PublicEmail: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /** Subject */
      subject: string;
      /** Slug */
      slug?: string;
      /**
       * Publish Date 
       * Format: date-time
       */
      publish_date?: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      /** Description */
      description: string;
      /** Absolute Url */
      absolute_url: string;
    };
    /** Page[PublicEmail] */
    PublicEmailPage: {
      /** Results */
      results: (components["schemas"]["PublicEmail"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** @enum {string} */
    EmailExcludableField: "body";
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /** List Exports */
  list_exports: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExportPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Export */
  create_export: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExportInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Export"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_CreateExportErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Export 
   * @description Retrieve a specific export by its ID
   */
  retrieve_export: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Export"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Tags */
  list_tags: {
    parameters: {
      query: {
        /** @description If provided, only return tags matching the given IDs. */
        ids?: (string)[];
        page_size?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["TagPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Tag */
  create_tag: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Tag"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Tag 
   * @description Retrieve a specific tag by its ID
   */
  retrieve_tag: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Tag"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Tag 
   * @description Delete a tag
   */
  delete_tag: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Tag 
   * @description Update a tag's properties
   */
  update_tag: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Tag"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_UpdateTagErrorCode_"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Tag Analytics 
   * @description Retrieve analytics for a specific tag
   */
  retrieve_tag_analytics: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["TagAnalytics"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Ping */
  ping: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Empty"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Get Account */
  get_account: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Account"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Images */
  list_images: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ImagePage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /** Create Image */
  create_image: {
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Image 
           * Format: binary
           */
          image: string;
        };
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Image"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Image 
   * @description Delete an uploaded image
   */
  delete_image: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Attachments */
  list_attachments: {
    parameters: {
      query: {
        /** @description If provided, only return attachments matching the given IDs. */
        ids?: (string)[];
        page_size?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AttachmentPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /** Create Attachment */
  create_attachment: {
    parameters: {
      query: {
        name?: string;
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * File 
           * Format: binary
           */
          file: string;
        };
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Attachment"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Attachment 
   * @description Retrieve an attachment
   */
  retrieve_attachment: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Attachment"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /**
   * Delete Attachment 
   * @description Delete an attachment
   */
  delete_attachment: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * List Books 
   * @description List all books for the authenticated newsletter
   */
  list_books: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["BookPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Create Book 
   * @description Create a new book
   */
  create_book: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["BookInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Book"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Book 
   * @description Retrieve a specific book by its ID
   */
  retrieve_book: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Book"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Book 
   * @description Delete a book
   */
  delete_book: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Book 
   * @description Update a book's properties
   */
  update_book: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BookUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Book"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Emails */
  list_emails: {
    parameters: {
      query: {
        /** @description If provided, only return emails with the given status. */
        status?: (components["schemas"]["EmailStatus"])[];
        /** @description If provided, only return emails without the given status. */
        negative_status?: (components["schemas"]["EmailStatus"])[];
        /** @description If provided, only return emails with the given ids. */
        ids?: (string)[];
        ordering?: "creation_date" | "-creation_date" | "status" | "-status" | "publish_date" | "-publish_date" | "subject" | "-subject" | "email_type" | "-email_type" | "modification_date" | "-modification_date" | "clicks" | "-clicks" | "opens" | "-opens" | "click_rate" | "-click_rate" | "open_rate" | "-open_rate" | "page_views_lifetime" | "-page_views_lifetime" | "page_views_30" | "-page_views_30" | "page_views_7" | "-page_views_7" | "webmentions" | "-webmentions" | "subscriptions" | "-subscriptions" | "paid_subscriptions" | "-paid_subscriptions" | "unsubscriptions" | "-unsubscriptions" | "replies" | "-replies" | "comments" | "-comments" | "social_mentions" | "-social_mentions" | "permanent_failure_rate" | "-permanent_failure_rate" | "complaint_rate" | "-complaint_rate";
        /** @description If provided, only return emails created after the given date. */
        creation_date__start?: string;
        /** @description If provided, only return emails created before the given date. */
        creation_date__end?: string;
        /** @description If provided, only return emails published after the given date. */
        publish_date__start?: string;
        /** @description If provided, only return emails published before the given date. */
        publish_date__end?: string;
        excluded_fields?: (components["schemas"]["EmailExcludableField"])[];
        source?: (components["schemas"]["EmailSource"])[];
        /** @description The type of emails to return. Defaults to all types. */
        email_type?: (components["schemas"]["EmailType"])[];
        /** @description If provided, only return emails with a subject that contains the given string. */
        subject?: string;
        /** @description If provided, only return emails with the given attachments. */
        attachments?: (string)[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["EmailPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_EmailListErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: never;
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Email */
  create_email: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["EmailInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Email"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_EmailCreationErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Email 
   * @description Retrieve a specific email by its ID
   */
  retrieve_email: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Email"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Email 
   * @description Delete an email
   */
  delete_email: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Email 
   * @description Update an email's properties
   */
  update_email: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EmailUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Email"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Email History 
   * @description Retrieve the edit history for a specific email
   */
  retrieve_email_history: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. */
        expand?: ("user")[];
        field: string;
        /** @description The page number of the paginated response. */
        page?: number;
        ordering?: "creation_date" | "-creation_date";
        query?: string;
        page_size?: number;
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["HistoryPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Email History By Id 
   * @description Retrieve a specific historical version of an email's body
   */
  retrieve_email_history_by_id: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. */
        expand?: ("user")[];
      };
      path: {
        id: string;
        history_id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["History"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Email Analytics 
   * @description Retrieve analytics for a specific email
   */
  retrieve_email_analytics: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Analytics"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Email Renders 
   * @description Retrieve rendered HTML for a specific email
   */
  retrieve_email_renders: {
    parameters: {
      query: {
        /** @description The target format for the rendered HTML. Use 'email' for rendered_html_for_email or 'html' for rendered_html_for_web. */
        target: "email" | "html";
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Render"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Send Draft 
   * @description Send a draft email to specific recipients
   */
  send_draft: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendDraftInput"];
      };
    };
    responses: {
      /** @description OK */
      200: never;
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Subscribers */
  list_subscribers: {
    parameters: {
      query: {
        /** @description If provided, only return subscribers with the given churn date(s). */
        churn_date__end?: string;
        /** @description If provided, only return subscribers with the given churn date(s). */
        churn_date__start?: string;
        /** @description If provided, only return subscribers with the given coupon ID(s). */
        coupon?: (string)[];
        /** @description If provided, only return subscribers who are currently subscribed to the given price ID(s). */
        current_price?: (string)[];
        /** @description If provided, only return subscribers created before the given date. */
        date__end?: string;
        /** @description If provided, only return subscribers created on or after the given date. */
        date__start?: string;
        /** @description If provided, only return subscribers whose email domain matches the given domain(s). */
        domain?: (string)[];
        /** @description If provided, only return subscribers whose email address contains the given string. */
        email_address?: string | (string)[];
        /** @description If provided, expand the given field. (Only supported fields: 'stripe_customer') */
        expand?: ("stripe_customer")[];
        /** @description If provided, only return subscribers with the given IDs. */
        ids?: (string)[];
        /** @description If provided, only return subscribers with the given IP address(es). */
        ip_address?: (string)[];
        /** @description If provided, only return subscribers with the given last click date(s). */
        last_click_date__end?: string;
        /** @description If provided, only return subscribers with the given last click date(s). */
        last_click_date__start?: string;
        /** @description If provided, only return subscribers with the given last open date(s). */
        last_open_date__end?: string;
        /** @description If provided, only return subscribers with the given last open date(s). */
        last_open_date__start?: string;
        /** @description If provided, only return subscribers whose email domain does not match the given domain(s). */
        "-domain"?: (string)[];
        "-tag"?: string;
        /** @description If provided, only return subscribers without the given type. */
        "-type"?: (components["schemas"]["SubscriberType"])[];
        ordering?: string;
        /** @description If provided, only return subscribers who have at one point subscribed to the given price ID(s). */
        price?: (string)[];
        /** @description If provided, only return subscribers with the given referral code(s). */
        referral_code?: (string)[];
        /** @description If provided, only return subscribers whose referrer URL(s) contain the given string. */
        referrer_url?: (string)[];
        /** @description If provided, only return subscribers with a risk score less than or equal to the given value. */
        risk_score__end?: number;
        /** @description If provided, only return subscribers with a risk score greater than or equal to the given value. */
        risk_score__start?: number;
        /** @description If provided, only return subscribers with the given source(s). */
        source?: (components["schemas"]["SubscriberSource"])[];
        /** @description If provided, only return subscribers that were imported by the given subscriber import. */
        subscriber_import?: (string)[];
        tag?: (string)[];
        /** @description If provided, only return subscribers with the given type. */
        type?: (components["schemas"]["SubscriberType"])[];
        /** @description If provided, only return subscribers with the given undeliverability date(s). */
        undeliverability_date__end?: string;
        /** @description If provided, only return subscribers with the given undeliverability date(s). */
        undeliverability_date__start?: string;
        /** @description If provided, only return subscribers with the given undeliverability reason(s). */
        undeliverability_reason?: (components["schemas"]["SubscriberUndeliverabilityReason"])[];
        /** @description If provided, only return subscribers with the given unsubscription date(s). */
        unsubscription_date__end?: string;
        /** @description If provided, only return subscribers with the given unsubscription date(s). */
        unsubscription_date__start?: string;
        /** @description If provided, only return subscribers with the given unsubscription reason(s). */
        unsubscription_reason?: (string)[];
        /** @description If provided, only return subscribers with the given upgrade date(s). */
        upgrade_date__end?: string;
        /** @description If provided, only return subscribers with the given upgrade date(s). */
        upgrade_date__start?: string;
        /** @description If provided, only return subscribers with the given UTM campaign(s). */
        utm_campaign?: (string)[];
        /** @description If provided, only return subscribers with the given UTM medium(s). */
        utm_medium?: (string)[];
        /** @description If provided, only return subscribers with the given UTM source(s). */
        utm_source?: (string)[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SubscriberPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_ListSubscribersErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /** Create Subscriber */
  create_subscriber: {
    parameters: {
      header: {
        /**
         * @description The behavior to apply when a subscriber with the same email address already exists.
         * Defaults to "no_op", which will return a 400 error if a subscriber with the same email address already exists. Other values include:
         * 
         * - "overwrite", which will overwrite the existing subscriber's data with the new one.
         * - "add", which will add the new subscriber data to the existing one.
         */
        "X-Buttondown-Collision-Behavior"?: "no_op" | "add" | "overwrite" | "fail";
        /** @description Bypass the firewall for this subscriber creation. Subject to aggressive rate limiting (5 per hour per newsletter). */
        "X-Buttondown-Bypass-Firewall"?: boolean;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SubscriberInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Subscriber"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_ValidationErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
      /** @description Too Many Requests */
      429: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /** Retrieve Subscriber */
  retrieve_subscriber: {
    parameters: {
      query: {
        expand?: ("stripe_customer")[];
      };
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Subscriber"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Delete Subscriber */
  delete_subscriber: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Update Subscriber */
  update_subscriber: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SubscriberUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Subscriber"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_UpdateSubscriberErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Send Reminder */
  send_reminder: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Send Magic Link To Subscriber */
  send_magic_link_to_subscriber: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Send Email To */
  send_email_to: {
    parameters: {
      path: {
        id_or_email: string;
        email_id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Empty"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Get Referrals */
  get_referrals: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SubscriberPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Get Automations */
  get_automations: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AutomationForSubscriberPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Update Automation Attempt */
  update_automation_attempt: {
    parameters: {
      path: {
        id_or_email: string;
        automation_attempt_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationAttemptUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AutomationForSubscriber"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_UpdateAutomationAttemptErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Get Stripe Subscriptions */
  get_stripe_subscriptions: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["StripeSubscriptionPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Newsletters */
  list_newsletters: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["NewsletterPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Newsletter */
  create_newsletter: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewsletterInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Newsletter"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_CreateNewsletterErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Newsletter 
   * @description Delete a newsletter
   */
  delete_newsletter: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Newsletter 
   * @description Update a newsletter's settings
   */
  update_newsletter: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewsletterUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Newsletter"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Bulk Action */
  create_bulk_action: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["BulkActionInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["BulkAction"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Bulk Action 
   * @description Retrieve the status of a bulk action
   */
  retrieve_bulk_action: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["BulkAction"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List External Feed */
  list_external_feed: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalFeedPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create External Feed */
  create_external_feed: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExternalFeedInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["ExternalFeed"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve External Feed 
   * @description Retrieve a specific external feed by its ID
   */
  retrieve_external_feed: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalFeed"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete External Feed 
   * @description Delete an external feed
   */
  delete_external_feed: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update External Feed 
   * @description Update an external feed's properties
   */
  update_external_feed: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExternalFeedUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalFeed"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Items 
   * @description Retrieve items from an external feed
   */
  retrieve_items: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. */
        expand?: ("email")[];
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalFeedItemPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Poll Items 
   * @description Poll for new items in an external feed
   */
  poll_items: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Empty"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Automations */
  list_automations: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AutomationPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Automation */
  create_automation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Automation"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_AutomationCreationErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Automation 
   * @description Retrieve a specific automation by its ID
   */
  retrieve_automation: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Automation"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Automation 
   * @description Delete an automation
   */
  delete_automation: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Automation 
   * @description Update an automation's properties
   */
  update_automation: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Automation"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Invoke Automation 
   * @description Manually trigger an automation
   */
  invoke_automation: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Automation Analytics 
   * @description Retrieve analytics data for an automation
   */
  retrieve_automation_analytics: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Analytics"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Users */
  list_users: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UserPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create User */
  create_user: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_Failure_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve User 
   * @description Retrieve a specific user by its ID
   */
  retrieve_user: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete User 
   * @description Delete a user
   */
  delete_user: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update User 
   * @description Update a user's properties
   */
  update_user: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Prices */
  list_prices: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. */
        expand?: ("product")[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["PricePage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_ListPricesErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Price */
  create_price: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PriceInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Price"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_CreatePriceErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Coupons */
  list_coupons: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["StripeCouponPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Surveys */
  list_surveys: {
    parameters: {
      query: {
        /** @description If provided, only return surveys with the given status. */
        status?: (components["schemas"]["SurveyStatus"])[];
        /** @description If provided, only return surveys without the given status. */
        "-status"?: (components["schemas"]["SurveyStatus"])[];
        ordering?: "creation_date" | "-creation_date" | "question" | "-question" | "identifier" | "-identifier" | "status" | "-status" | "response_count" | "-response_count";
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SurveyPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Survey */
  create_survey: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SurveyInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Survey"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_CreateSurveyErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Survey 
   * @description Retrieve a specific survey by its ID
   */
  retrieve_survey: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Survey"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Survey 
   * @description Delete a survey
   */
  delete_survey: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Survey 
   * @description Update a survey's properties
   */
  update_survey: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SurveyUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Survey"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_UpdateSurveyErrorCode_"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Forms */
  list_forms: {
    parameters: {
      query: {
        /** @description If provided, only return forms with the given status. */
        status?: (components["schemas"]["FormStatus"])[];
        /** @description If provided, only return forms without the given status. */
        "-status"?: (components["schemas"]["FormStatus"])[];
        /** @description If provided, filter by admin-only flag. */
        admin?: boolean;
        ordering?: "creation_date" | "-creation_date" | "title" | "-title" | "slug" | "-slug" | "status" | "-status";
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["FormPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Form */
  create_form: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FormInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Form"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_CreateFormErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Form 
   * @description Retrieve a specific form by its ID
   */
  retrieve_form: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Form"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Form 
   * @description Delete a form
   */
  delete_form: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Form 
   * @description Update a form's properties
   */
  update_form: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["FormUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Form"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Api Request 
   * @description Retrieve a specific API request by its ID
   */
  retrieve_api_request: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["APIRequestDetail"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Api Requests */
  list_api_requests: {
    parameters: {
      query: {
        status_code?: (string)[];
        method?: (string)[];
        source?: (components["schemas"]["APIRequestSource"])[];
        version?: ("2024-07-01" | "2024-08-01" | "2024-08-15" | "2024-09-30" | "2024-12-30" | "2025-01-02" | "2025-05-19" | "2025-06-01" | "2026-01-01")[];
        date__start?: string;
        date__end?: string;
        creation_date__lt?: string;
        creation_date__gt?: string;
        path?: (string)[];
        limit?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["APIRequestList"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Advertising Units */
  list_advertising_units: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AdvertisingUnitPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Advertising Unit */
  create_advertising_unit: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdvertisingUnitInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["AdvertisingUnit"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Advertising Unit 
   * @description Delete an advertising unit
   */
  delete_advertising_unit: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Advertising Unit 
   * @description Update an advertising unit's properties
   */
  update_advertising_unit: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdvertisingUnitUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AdvertisingUnit"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * List Advertising Slots 
   * @description List all advertising slots
   */
  list_advertising_slots: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AdvertisingSlotPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Advertising Slot 
   * @description Update an advertising slot's sponsor content
   */
  update_advertising_slot: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdvertisingSlotUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AdvertisingSlot"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Webhooks */
  list_webhooks: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebhookPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Webhook */
  create_webhook: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebhookInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Webhook"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Webhook 
   * @description Retrieve a specific webhook by its ID
   */
  retrieve_webhook: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Webhook"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Webhook 
   * @description Delete a webhook
   */
  delete_webhook: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Webhook 
   * @description Update a webhook's properties
   */
  update_webhook: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebhookInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Webhook"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Webhook Attempts 
   * @description Retrieve webhook attempts for a specific webhook
   */
  retrieve_webhook_attempts: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebhookAttemptOutputPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Test Webhook 
   * @description Send a test event to a webhook
   */
  test_webhook: {
    parameters: {
      query: {
        /**
         * @description Various types of events that are recorded by Buttondown, both in terms of exogenous systems
         * like Stripe and Memberful, and endogenous ones like email opens and clicks. (In general, if anything
         * important ever happens that could be relevant to your newsletter, we have an event type for it!)
         * 
         * These event types power lots of things within Buttondown. They're used to trigger automations, webhooks,
         * and analytics.
         * 
         * (Note that Buttondown also has a different thing we call "events"; those are `EmailEvents` and are used
         * for tracking aggregate details about an email. Alas, we shouldn't have used the term "event" for two different
         * things, but it's too late to go back now!)
         * 
         * In general, our event namespacing tries to hew to the following pattern:
         * 
         * <source>.<object>.<action>
         * 
         * When wondering which object we are referring to, default to the _more granular_ object.
         * 
         * For instance, an email being sent to a subscriber is `subscriber.delivered`, not `email.sent`.
         */
        event_type?: "advertising_slot.purchased" | "automation.invoked" | "date.day.started" | "date.month.started" | "date.week.started" | "date.year.started" | "email.created" | "email.deleted" | "email.sent" | "email.status.changed" | "email.updated" | "external_feed_item.created" | "export.completed" | "export.created" | "export.failed" | "firewall.blocked" | "mention.created" | "memberful.member.updated" | "memberful.subscription.created" | "memberful.subscription.deleted" | "note.created" | "note.deleted" | "patreon.member.updated" | "patreon.membership.created" | "patreon.membership.deleted" | "shopify.customer.created" | "shopify.customer.updated" | "social_mention.created" | "stripe.checkout.session.completed" | "stripe.customer.updated" | "stripe.subscription.activated" | "stripe.subscription.churning" | "stripe.subscription.deactivated" | "subscriber.bounced" | "subscriber.changed_email" | "subscriber.churned" | "subscriber.clicked" | "subscriber.commented" | "subscriber.complained" | "subscriber.confirmed" | "subscriber.created" | "subscriber.deleted" | "subscriber.delivered" | "subscriber.opened" | "subscriber.paid" | "subscriber.paused" | "subscriber.resumed" | "subscriber.referred" | "subscriber.referred.paid" | "subscriber.rejected" | "subscriber.replied" | "subscriber.responded_to_survey" | "subscriber.tags.changed" | "subscriber.trial_ended" | "subscriber.trial_started" | "subscriber.type.changed" | "subscriber.unsubscribed" | "subscriber.updated" | "subscriber.viewed_checkout_page" | "survey.cleared_responses" | "survey.created" | "survey.deleted" | "survey.updated" | "form.created" | "form.deleted" | "form.updated";
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Comments */
  list_comments: {
    parameters: {
      query: {
        /** @description If provided, only return comments of the given type. */
        comment_type: "reviewer" | "subscriber";
        /** @description If provided, only return comments for the given email. */
        email_id?: string;
        /** @description If provided, only return comments for the given subscriber. */
        subscriber_id?: string;
        /** @description If provided, only return comments that are replies to the given parent comment. */
        parent_id?: string;
        /** @description If provided, expand the given field. (Only supported fields: 'subscriber', 'email'). */
        expand?: ("subscriber" | "email")[];
        ordering?: "creation_date" | "-creation_date" | "email" | "-email" | "subscriber" | "-subscriber";
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CommentPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Create Comment 
   * @description Create a new comment or reply to an existing comment. Authors can respond to comments at the given author.
   */
  create_comment: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CommentInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Comment"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Comment 
   * @description Retrieve a specific comment by its ID
   */
  retrieve_comment: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Comment"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Comment 
   * @description Delete a comment. Only the comment owner (subscriber) or the newsletter author can delete a comment.
   */
  delete_comment: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /** Retrieve Survey Responses */
  retrieve_survey_responses: {
    parameters: {
      query: {
        /** @description If provided, only return responses made to the given email. */
        email_id?: string;
        /** @description If provided, only return responses made by the given subscriber. */
        subscriber_id?: string;
        /** @description If provided, only return responses made to the given survey(s). */
        survey?: (string)[];
        /** @description If provided, only return responses made after the given date. */
        creation_date__start?: string;
        /** @description If provided, only return responses made before the given date. */
        creation_date__end?: string;
        /** @description If provided, expand the given field. */
        expand?: ("email" | "subscriber" | "survey" | "automation")[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ResponsePage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Survey Response */
  create_survey_response: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResponseInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Response"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Survey Response 
   * @description Update a survey response's text. Only the response owner (subscriber) can update their response.
   */
  update_survey_response: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResponseUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Response"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /** List Events */
  list_events: {
    parameters: {
      query: {
        event_type?: components["schemas"]["EmailEventType"];
        ordering?: "creation_date" | "-creation_date";
        /** @description If provided, expand the given field. (Only supported field: 'subscriber'). */
        expand?: ("automation" | "subscriber" | "email")[];
        email_id?: string;
        automation_id?: string;
        subscriber_id?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["EmailEventPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Get Event 
   * @description Retrieve a specific event by its ID
   */
  get_event: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. (Only supported field: 'subscriber'). */
        expand?: ("automation" | "subscriber" | "email")[];
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["EmailEvent"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /** List Notes */
  list_notes: {
    parameters: {
      query: {
        /** @description Filter notes by the type of object they are attached to. */
        model_type?: "email" | "subscriber" | "external_feed" | "automation" | "survey" | "stripe_customer" | "tag" | "comment" | "conversation" | "webmention" | "socialmention";
        /** @description Filter notes by the ID of the object they are attached to. */
        model_id?: string;
        /** @description If provided, expand the given field. */
        expand?: ("user")[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["NotePage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Note Endpoint */
  create_note_endpoint: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["NoteInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Note"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Note Endpoint 
   * @description Delete a note
   */
  delete_note_endpoint: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Search public emails 
   * @description Search and list public emails for a newsletter. No authentication required.
   */
  list_public_emails: {
    parameters: {
      query: {
        q?: string;
        page?: number;
      };
      path: {
        username: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["PublicEmailPage"];
        };
      };
      /** @description Not Found */
      404: never;
    };
  };
}
