/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/exports": {
    /** List Exports */
    get: operations["list_exports"];
    /** Create Export */
    post: operations["create_export"];
  };
  "/exports/{id}": {
    /**
     * Retrieve Export 
     * @description Retrieve a specific export by its ID
     */
    get: operations["retrieve_export"];
  };
  "/tags": {
    /** List Tags */
    get: operations["list_tags"];
    /** Create Tag */
    post: operations["create_tag"];
  };
  "/tags/{id}": {
    /**
     * Retrieve Tag 
     * @description Retrieve a specific tag by its ID
     */
    get: operations["retrieve_tag"];
    /**
     * Delete Tag 
     * @description Delete a tag
     */
    delete: operations["delete_tag"];
    /**
     * Update Tag 
     * @description Update a tag's properties
     */
    patch: operations["update_tag"];
  };
  "/tags/{id}/analytics": {
    /**
     * Retrieve Tag Analytics 
     * @description Retrieve analytics for a specific tag
     */
    get: operations["retrieve_tag_analytics"];
  };
  "/ping": {
    /** Ping */
    get: operations["ping"];
  };
  "/accounts/me": {
    /** Get Account */
    get: operations["get_account"];
  };
  "/images": {
    /** List Images */
    get: operations["list_images"];
    /** Create Image */
    post: operations["create_image"];
  };
  "/images/{id}": {
    /**
     * Delete Image 
     * @description Delete an uploaded image
     */
    delete: operations["delete_image"];
  };
  "/attachments": {
    /** List Attachments */
    get: operations["list_attachments"];
    /** Create Attachment */
    post: operations["create_attachment"];
  };
  "/attachments/{id}": {
    /**
     * Delete Attachment 
     * @description Delete an attachment
     */
    delete: operations["delete_attachment"];
  };
  "/emails": {
    /** List Emails */
    get: operations["list_emails"];
    /** Create Email */
    post: operations["create_email"];
  };
  "/emails/{id}": {
    /**
     * Retrieve Email 
     * @description Retrieve a specific email by its ID
     */
    get: operations["retrieve_email"];
    /**
     * Update Email 
     * @description Update an email's properties
     */
    patch: operations["update_email"];
  };
  "/emails/{id}/history": {
    /**
     * Retrieve Email History 
     * @description Retrieve the edit history for a specific email
     */
    get: operations["retrieve_email_history"];
  };
  "/emails/{id}/history/body/{history_id}": {
    /**
     * Retrieve Email History By Id 
     * @description Retrieve a specific historical version of an email's body
     */
    get: operations["retrieve_email_history_by_id"];
  };
  "/emails/{id}/analytics": {
    /**
     * Retrieve Email Analytics 
     * @description Retrieve analytics for a specific email
     */
    get: operations["retrieve_email_analytics"];
  };
  "/emails/{id}/send-draft": {
    /**
     * Send Draft 
     * @description Send a draft email to specific recipients
     */
    post: operations["send_draft"];
  };
  "/subscribers": {
    /** List Subscribers */
    get: operations["list_subscribers"];
    /** Create Subscriber */
    post: operations["create_subscriber"];
  };
  "/subscribers/{id_or_email}": {
    /** Retrieve Subscriber */
    get: operations["retrieve_subscriber"];
    /** Delete Subscriber */
    delete: operations["delete_subscriber"];
    /** Update Subscriber */
    patch: operations["update_subscriber"];
  };
  "/subscribers/{id_or_email}/send-reminder": {
    /** Send Reminder */
    post: operations["send_reminder"];
  };
  "/subscribers/{id_or_email}/emails/{email_id}": {
    /** Send Email To */
    post: operations["send_email_to"];
  };
  "/subscribers/{id_or_email}/referrals": {
    /** Get Referrals */
    get: operations["get_referrals"];
  };
  "/subscribers/{id_or_email}/automations": {
    /** Get Automations */
    get: operations["get_automations"];
  };
  "/subscribers/{id_or_email}/stripe-subscriptions": {
    /** Get Stripe Subscriptions */
    get: operations["get_stripe_subscriptions"];
  };
  "/newsletters": {
    /** List Newsletters */
    get: operations["list_newsletters"];
    /** Create Newsletter */
    post: operations["create_newsletter"];
  };
  "/newsletters/{id}": {
    /**
     * Delete Newsletter 
     * @description Delete a newsletter
     */
    delete: operations["delete_newsletter"];
    /**
     * Update Newsletter 
     * @description Update a newsletter's settings
     */
    patch: operations["update_newsletter"];
  };
  "/bulk_actions": {
    /** Create Bulk Action */
    post: operations["create_bulk_action"];
  };
  "/bulk_actions/{id}": {
    /**
     * Retrieve Bulk Action 
     * @description Retrieve the status of a bulk action
     */
    get: operations["retrieve_bulk_action"];
  };
  "/external_feeds": {
    /** List External Feed */
    get: operations["list_external_feed"];
    /** Create External Feed */
    post: operations["create_external_feed"];
  };
  "/external_feeds/{id}": {
    /**
     * Retrieve External Feed 
     * @description Retrieve a specific external feed by its ID
     */
    get: operations["retrieve_external_feed"];
    /**
     * Delete External Feed 
     * @description Delete an external feed
     */
    delete: operations["delete_external_feed"];
    /**
     * Update External Feed 
     * @description Update an external feed's properties
     */
    patch: operations["update_external_feed"];
  };
  "/external_feeds/{id}/items": {
    /**
     * Retrieve Items 
     * @description Retrieve items from an external feed
     */
    get: operations["retrieve_items"];
    /**
     * Poll Items 
     * @description Poll for new items in an external feed
     */
    post: operations["poll_items"];
  };
  "/automations": {
    /** List Automations */
    get: operations["list_automations"];
    /** Create Automation */
    post: operations["create_automation"];
  };
  "/automations/{id}/subscribers": {
    /**
     * Retrieve Automation Subscribers 
     * @description Retrieve subscribers associated with an automation
     */
    get: operations["retrieve_automation_subscribers"];
  };
  "/automations/{id}": {
    /**
     * Retrieve Automation 
     * @description Retrieve a specific automation by its ID
     */
    get: operations["retrieve_automation"];
    /**
     * Delete Automation 
     * @description Delete an automation
     */
    delete: operations["delete_automation"];
    /**
     * Update Automation 
     * @description Update an automation's properties
     */
    patch: operations["update_automation"];
  };
  "/automations/{id}/invoke": {
    /**
     * Invoke Automation 
     * @description Manually trigger an automation
     */
    post: operations["invoke_automation"];
  };
  "/automations/{id}/analytics": {
    /**
     * Retrieve Automation Analytics 
     * @description Retrieve analytics data for an automation
     */
    get: operations["retrieve_automation_analytics"];
  };
  "/users": {
    /** List Users */
    get: operations["list_users"];
    /** Create User */
    post: operations["create_user"];
  };
  "/users/{id}": {
    /**
     * Retrieve User 
     * @description Retrieve a specific user by its ID
     */
    get: operations["retrieve_user"];
    /**
     * Delete User 
     * @description Delete a user
     */
    delete: operations["delete_user"];
    /**
     * Update User 
     * @description Update a user's properties
     */
    patch: operations["update_user"];
  };
  "/prices": {
    /** List Prices */
    get: operations["list_prices"];
    /** Create Price */
    post: operations["create_price"];
  };
  "/coupons": {
    /** List Coupons */
    get: operations["list_coupons"];
  };
  "/surveys": {
    /** List Surveys */
    get: operations["list_surveys"];
    /** Create Survey */
    post: operations["create_survey"];
  };
  "/surveys/{id}": {
    /**
     * Retrieve Survey 
     * @description Retrieve a specific survey by its ID
     */
    get: operations["retrieve_survey"];
    /**
     * Delete Survey 
     * @description Delete a survey
     */
    delete: operations["delete_survey"];
    /**
     * Update Survey 
     * @description Update a survey's properties
     */
    patch: operations["update_survey"];
  };
  "/api_requests/{id}": {
    /**
     * Retrieve Api Request 
     * @description Retrieve a specific API request by its ID
     */
    get: operations["retrieve_api_request"];
  };
  "/api_requests": {
    /** List Api Requests */
    get: operations["list_api_requests"];
  };
  "/advertising_units": {
    /** List Advertising Units */
    get: operations["list_advertising_units"];
    /** Create Advertising Unit */
    post: operations["create_advertising_unit"];
  };
  "/advertising_units/{id}": {
    /**
     * Delete Advertising Unit 
     * @description Delete an advertising unit
     */
    delete: operations["delete_advertising_unit"];
    /**
     * Update Advertising Unit 
     * @description Update an advertising unit's properties
     */
    patch: operations["update_advertising_unit"];
  };
  "/advertising_units/slots/{id}": {
    /**
     * Update Advertising Slot 
     * @description Update an advertising slot's sponsor content
     */
    patch: operations["update_advertising_slot"];
  };
  "/webhooks": {
    /** List Webhooks */
    get: operations["list_webhooks"];
    /** Create Webhook */
    post: operations["create_webhook"];
  };
  "/webhooks/{id}": {
    /**
     * Retrieve Webhook 
     * @description Retrieve a specific webhook by its ID
     */
    get: operations["retrieve_webhook"];
    /**
     * Delete Webhook 
     * @description Delete a webhook
     */
    delete: operations["delete_webhook"];
    /**
     * Update Webhook 
     * @description Update a webhook's properties
     */
    patch: operations["update_webhook"];
  };
  "/webhooks/{id}/attempts": {
    /**
     * Retrieve Webhook Attempts 
     * @description Retrieve webhook attempts for a specific webhook
     */
    get: operations["retrieve_webhook_attempts"];
  };
  "/webhooks/{id}/test": {
    /**
     * Test Webhook 
     * @description Send a test event to a webhook
     */
    post: operations["test_webhook"];
  };
  "/comments/{id}": {
    /**
     * Retrieve Comment 
     * @description Retrieve a specific comment by its ID
     */
    get: operations["retrieve_comment"];
  };
  "/comments": {
    /** List Comments */
    get: operations["list_comments"];
  };
  "/survey_responses": {
    /** Retrieve Survey Responses */
    get: operations["retrieve_survey_responses"];
    /** Create Survey Response */
    post: operations["create_survey_response"];
  };
  "/events": {
    /** List Events */
    get: operations["list_events"];
  };
  "/events/{id}": {
    /**
     * Get Event 
     * @description Retrieve a specific event by its ID
     */
    get: operations["get_event"];
  };
  "/notes": {
    /** List Notes */
    get: operations["list_notes"];
    /** Create Note Endpoint */
    post: operations["create_note_endpoint"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * Collection 
     * @description A group of data that can be exported in an export. 
     * @enum {string}
     */
    ExportCollection: "subscribers" | "emails" | "events" | "referrals" | "surveys" | "comments" | "requests" | "mentions" | "conversations" | "images" | "stripe_subscriptions" | "stripe_products" | "stripe_customers" | "stripe_prices" | "stripe_charges";
    /**
     * Format 
     * @description An enumeration. 
     * @enum {string}
     */
    ExportFormat: "csv" | "json";
    /**
     * Status 
     * @description Represents the status of an export.
     * 
     * No action is required to move from one state or another; Buttondown
     * internally handles the transitions, and exposing the status is for
     * observability purposes only. 
     * @enum {string}
     */
    ExportStatus: "error" | "in_progress" | "not_started" | "ready";
    /**
     * Export 
     * @description Some software applications may want programmatic access to their newsletter exports.
     * This assists with a few niche use cases, such as regular backups or data ingestion
     * (into a data warehouse), or post-publishing processes that hinge on email events.
     * 
     * In general, you probably won't _need_ to use this endpoint unless you
     * _absolutely_ need to use this endpoint.
     * 
     * To browse the contents of a given export collection, refer to the [Data exports](https://docs.buttondown.com/data-exports-subscriber) section
     * of the documentation.
     */
    Export: {
      /** @description The [collections](https://docs.buttondown.com/api-exports-collections) of objects to export. */
      collections: (components["schemas"]["ExportCollection"])[];
      /**
       * Parameters 
       * @description Parameters to pass to the exporter. These are specific to the collection and format, and constrain the export.
       */
      parameters?: Record<string, unknown>;
      /**
       * @description The [format](https://docs.buttondown.com/api-exports-format) of the export files. 
       * @default csv
       */
      format?: components["schemas"]["ExportFormat"];
      /**
       * Columns 
       * @description If provided, the export will only include these columns.
       */
      columns?: (string)[];
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /** Url */
      url?: string;
      /**
       * Completion Date 
       * Format: date-time
       */
      completion_date?: string;
      status: components["schemas"]["ExportStatus"];
    };
    /** ErrorMessage */
    ErrorMessage: {
      /** Code */
      code?: Record<string, unknown>;
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /**
     * CreateExportErrorCode 
     * @description An enumeration. 
     * @enum {string}
     */
    CreateExportErrorCode: "collection_empty_invalid" | "columns_empty_invalid" | "columns_invalid";
    /** ErrorMessage[CreateExportErrorCode] */
    ErrorMessage_CreateExportErrorCode_: {
      code: components["schemas"]["CreateExportErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** ExportInput */
    ExportInput: {
      /** @description The [collections](https://docs.buttondown.com/api-exports-collections) of objects to export. */
      collections: (components["schemas"]["ExportCollection"])[];
      /**
       * Parameters 
       * @description Parameters to pass to the exporter. These are specific to the collection and format, and constrain the export.
       */
      parameters?: Record<string, unknown>;
      /**
       * @description The [format](https://docs.buttondown.com/api-exports-format) of the export files. 
       * @default csv
       */
      format?: components["schemas"]["ExportFormat"];
      /**
       * Columns 
       * @description If provided, the export will only include these columns.
       */
      columns?: (string)[];
    };
    /** Page[Export] */
    ExportPage: {
      /** Results */
      results: (components["schemas"]["Export"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Tag 
     * @description Tags are a way to organize your subscribers. You can create, update, and
     * delete tags via the API. You can also list all tags for a given newsletter.
     * 
     * Tags don't have any strict functionality on their own, but you can send emails
     * to subscribers with a given tag (or to all subscribers _without_ a given tag.)
     */
    Tag: {
      /**
       * Name 
       * @example VIP
       */
      name: string;
      /**
       * Color 
       * @example #FFD700
       */
      color: string;
      /** Description */
      description?: string;
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /** Secondary Id */
      secondary_id: number;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
    };
    /** TagInput */
    TagInput: {
      /**
       * Name 
       * @example VIP
       */
      name: string;
      /**
       * Color 
       * @example #FFD700
       */
      color: string;
      /** Description */
      description?: string;
    };
    /** Page[Tag] */
    TagPage: {
      /** Results */
      results: (components["schemas"]["Tag"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * UpdateTagErrorCode 
     * @description A potential error code that can be returned when updating a tag. 
     * @enum {string}
     */
    UpdateTagErrorCode: "name_already_exists" | "name_too_long";
    /** ErrorMessage[UpdateTagErrorCode] */
    ErrorMessage_UpdateTagErrorCode_: {
      code: components["schemas"]["UpdateTagErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** TagUpdateInput */
    TagUpdateInput: {
      /**
       * Name 
       * @example VIP
       */
      name?: string;
      /**
       * Color 
       * @example #FFD700
       */
      color?: string;
      /** Description */
      description?: string;
      /** Secondary Id */
      secondary_id?: number;
    };
    /** TagAnalytics */
    TagAnalytics: {
      /** Created Subscribers */
      created_subscribers: number;
      /** Click Rate */
      click_rate: number;
      /** Open Rate */
      open_rate: number;
      /** Retention */
      retention: number;
    };
    /** Empty */
    Empty: Record<string, unknown>;
    /** Account */
    Account: {
      /** Username */
      username: string;
      /** Email Address */
      email_address: string;
    };
    /**
     * Image 
     * @description Images are, well, images! Buttondown allows you to upload images to its secure
     * S3 bucket and do with them what you will. This is sort of an odd duck of an
     * API, to be sure, but if you want to be able to do things like draft
     * and send emails completely on your iPad you need a surefire way of creating images.
     */
    Image: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      /**
       * Image 
       * @description The URL of the image. 
       * @example https://placekitten.com/408/287
       */
      image: string;
    };
    /** Page[Image] */
    ImagePage: {
      /** Results */
      results: (components["schemas"]["Image"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Attachment 
     * @description Attachments are files that can be included with your emails. Buttondown allows
     * you to upload attachments to its secure S3 bucket and attach them to your emails.
     * Supported file types include documents, images, audio files, and more.
     */
    Attachment: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      /**
       * Name 
       * @description The name of the attachment. 
       * @example newsletter-guide.pdf
       */
      name: string;
      /**
       * File 
       * @description The URL of the attachment file. 
       * @example https://buttondown.s3.amazonaws.com/attachments/newsletter-guide.pdf
       */
      file: string;
    };
    /** Page[Attachment] */
    AttachmentPage: {
      /** Results */
      results: (components["schemas"]["Attachment"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Status 
     * @description Represents the state of an email.
     * 
     * No action is required to move from one state or another; Buttondown
     * internally handles the transitions, and exposing the status is for
     * observability purposes only. 
     * @enum {string}
     */
    EmailStatus: "draft" | "managed_by_rss" | "about_to_send" | "scheduled" | "in_flight" | "paused" | "deleted" | "errored" | "sent" | "imported" | "throttled" | "resending" | "transactional";
    /**
     * Type 
     * @description Represents the audience of an email, and to whom it is visible both in the initial
     * email and in online archives. 
     * @enum {string}
     */
    EmailType: "public" | "private" | "premium" | "free" | "churned" | "archival";
    /**
     * Source 
     * @description Represents the original provenance of an email. This value is not exposed
     * to subscribers, but does determine some behavior of the email (e.g. whether
     * or not analytics can be calculated.) 
     * @enum {string}
     */
    EmailSource: "api" | "import" | "app" | "external_feed";
    /**
     * CommentingMode 
     * @description Governs who can comment on this email.
     * 
     * This enum replaces the `is_comments_disabled` field, which has been deprecated. (Also note that this field may be superseded by newsletter-level settings; for instance, "enabled" is an invalid and inert value if the newsletter itself has comments disabled.) 
     * @enum {string}
     */
    EmailCommentingMode: "disabled" | "enabled" | "enabled_for_paid_subscribers";
    /**
     * Operator 
     * @description An enumeration. 
     * @enum {string}
     */
    Operator: "equals" | "not_equals" | "contains" | "not_contains" | "is_empty" | "is_not_empty" | "greater_than" | "less_than";
    /** Filter */
    Filter: {
      /** Field */
      field: string;
      operator: components["schemas"]["Operator"];
      /** Value */
      value: string;
    };
    /**
     * FilterGroup 
     * @description Buttondown's filtering schema can be used for multiple things:
     * 
     * - Filtering [the audience of an email](/api-emails-create) to a specific subset
     * - Creating [finely-tuned automations](/api-automation-introduction)
     */
    FilterGroup: {
      /** Filters */
      filters: (components["schemas"]["Filter"])[];
      /** Groups */
      groups: (components["schemas"]["FilterGroup"])[];
      /**
       * Predicate 
       * @description The logical operator to use when combining filters (either 'and' or 'or'). 
       * @enum {string}
       */
      predicate: "and" | "or";
    };
    /** Analytics */
    Analytics: {
      /**
       * Recipients 
       * @default 0
       */
      recipients?: number;
      /**
       * Deliveries 
       * @default 0
       */
      deliveries?: number;
      /**
       * Opens 
       * @default 0
       */
      opens?: number;
      /**
       * Clicks 
       * @default 0
       */
      clicks?: number;
      /**
       * Temporary Failures 
       * @default 0
       */
      temporary_failures?: number;
      /**
       * Permanent Failures 
       * @default 0
       */
      permanent_failures?: number;
      /**
       * Unsubscriptions 
       * @default 0
       */
      unsubscriptions?: number;
      /**
       * Complaints 
       * @default 0
       */
      complaints?: number;
      /**
       * Survey Responses 
       * @default 0
       */
      survey_responses?: number;
      /**
       * Webmentions 
       * @default 0
       */
      webmentions?: number;
      /**
       * Page Views  Lifetime 
       * @default 0
       */
      page_views__lifetime?: number;
      /**
       * Page Views  30 
       * @default 0
       */
      page_views__30?: number;
      /**
       * Page Views  7 
       * @default 0
       */
      page_views__7?: number;
      /**
       * Subscriptions 
       * @default 0
       */
      subscriptions?: number;
      /**
       * Paid Subscriptions 
       * @default 0
       */
      paid_subscriptions?: number;
      /**
       * Replies 
       * @default 0
       */
      replies?: number;
      /**
       * Comments 
       * @default 0
       */
      comments?: number;
      /**
       * Social Mentions 
       * @default 0
       */
      social_mentions?: number;
    };
    /**
     * EmailTemplate 
     * @description Represents the template of an email.
     * 
     * Each template has a different layout/style; you can view screenshots and examples [in the docs](https://docs.buttondown.com/customizing-email-design#buttondowns-default-templates). 
     * @enum {string}
     */
    NewsletterEmailTemplate: "classic" | "modern" | "airy" | "plaintext" | "naked";
    /**
     * Email 
     * @description Emails are why you're here on Buttondown, right?
     * Creating an email via the API is just like creating one in the interface;
     * it will instantly trigger sending actual emails,
     * based on the tags and email type you provide.
     * 
     * Relevant changes to the schema:
     * 
     * - [2024-08-15](https://docs.buttondown.com/api-changelog-2024-08-15): unshipped the `included_tags` and `excluded_tags` fields.
     * - [2024-12-30](https://docs.buttondown.com/api-changelog-2024-12-30): unshipped the `is_comments_disabled` field, and replaced it with a more flexible `commenting_mode` field.
     */
    Email: {
      /**
       * Id 
       * Format: uuid 
       * @description The unique identifier for the email.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was first created.
       */
      creation_date: string;
      /**
       * Modification Date 
       * Format: date-time 
       * @description The date and time at which the object was last modified.
       */
      modification_date: string;
      /**
       * Publish Date 
       * Format: date-time 
       * @description The date and time at which the email should be published in the future (for scheduled emails), or the date and time at which the email was published (for sent emails).
       */
      publish_date?: string;
      /**
       * Subject 
       * @description The subject line for the email.
       */
      subject: string;
      /**
       * Body 
       * @description The body of the email. Can be either HTML or markdown.
       */
      body: string;
      /** @description The current status of the email. */
      status: components["schemas"]["EmailStatus"];
      /**
       * Slug 
       * @description A short, human-readable identifier for the email. (Used in the URL of the email, and in the 'slug' field of the email object.)
       */
      slug?: string;
      /**
       * Canonical Url 
       * @description The URL of the original source of the content.
       */
      canonical_url: string;
      /** @default public */
      email_type?: components["schemas"]["EmailType"];
      /**
       * Image 
       * @description A primary image to be used when previewing the email on the web or in other contexts.
       */
      image: string;
      /**
       * Description 
       * @description A human-readable description of the email, used for archives and SEO.
       */
      description: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
      /** @description The source of the email. */
      source: components["schemas"]["EmailSource"];
      /**
       * Secondary Id 
       * @description An informal 'number' for the email, used in some templates ('This was issue #123').
       */
      secondary_id?: number;
      commenting_mode: components["schemas"]["EmailCommentingMode"];
      /** Absolute Url */
      absolute_url: string;
      filters: components["schemas"]["FilterGroup"];
      analytics?: components["schemas"]["Analytics"];
      /** @description If present, this template overrides your newsletter's default template. */
      template?: components["schemas"]["NewsletterEmailTemplate"];
      /**
       * Attachments 
       * @description A list of attachment IDs present on the email. (See [Attachments](https://docs.buttondown.com/api-attachments-introduction) for more information.)
       */
      attachments?: (string)[];
      /**
       * Related Email Ids 
       * @description A list of email IDs that are related to this email. Related emails are shown at the bottom of the email and archive pages.
       */
      related_email_ids: (string)[];
      /**
       * Featured 
       * @description Designated whether or not this email should be highlighted within the archives. (Currently unused.)
       */
      featured: boolean;
      /**
       * Should Trigger Pay Per Email Billing 
       * @description Whether this email should trigger pay-per-email billing for paid subscribers. Use this to differentiate between free updates and premium newsletters.
       */
      should_trigger_pay_per_email_billing: boolean;
    };
    /**
     * EmailCreationErrorCode 
     * @description Represents the type of error that occurred when creating an email.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    EmailCreationErrorCode: "subject_invalid" | "email_duplicate" | "email_invalid" | "body_invalid" | "publish_date_invalid" | "publish_date_missing" | "status_invalid" | "slug_invalid" | "canonical_url_invalid" | "tag_invalid";
    /** ErrorMessage[EmailCreationErrorCode] */
    ErrorMessage_EmailCreationErrorCode_: {
      code: components["schemas"]["EmailCreationErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** EmailInput */
    EmailInput: {
      /**
       * Attachments 
       * @default []
       */
      attachments?: (string)[];
      /**
       * Publish Date 
       * Format: date-time
       */
      publish_date?: string;
      /**
       * Subject 
       * @example The subject line for the email
       */
      subject: string;
      /** Slug */
      slug?: string;
      /**
       * Description 
       * @default
       */
      description?: string;
      /**
       * Canonical Url 
       * @default
       */
      canonical_url?: string;
      /**
       * Image 
       * @default
       */
      image?: string;
      /**
       * Body 
       * @description Can be either HTML or markdown. 
       * @default  
       * @example This is an example of the body of an email.
       */
      body?: string;
      /** @default public */
      email_type?: components["schemas"]["EmailType"];
      /** @default about_to_send */
      status?: components["schemas"]["EmailStatus"];
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
      /** Secondary Id */
      secondary_id?: number;
      /**
       * Filters 
       * @default {
       *   "filters": [],
       *   "groups": [],
       *   "predicate": "and"
       * }
       */
      filters?: components["schemas"]["FilterGroup"];
      /** @default enabled */
      commenting_mode?: components["schemas"]["EmailCommentingMode"];
      /**
       * Related Email Ids 
       * @default []
       */
      related_email_ids?: (string)[];
      /**
       * Featured 
       * @description Designated whether or not this email should be highlighted within the archives. (Currently unused.) 
       * @default false
       */
      featured?: boolean;
      /**
       * Should Trigger Pay Per Email Billing 
       * @description Whether this email should trigger pay-per-email billing for paid subscribers. Use this to differentiate between free updates and premium newsletters. 
       * @default false
       */
      should_trigger_pay_per_email_billing?: boolean;
    };
    /** Page[Email] */
    EmailPage: {
      /** Results */
      results: (components["schemas"]["Email"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * EmailListErrorCode 
     * @description Represents the type of error that occurred when listing emails.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    EmailListErrorCode: "creation_date_invalid" | "publish_date_invalid";
    /** ErrorMessage[EmailListErrorCode] */
    ErrorMessage_EmailListErrorCode_: {
      code: components["schemas"]["EmailListErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** EmailUpdateInput */
    EmailUpdateInput: {
      /**
       * Attachments 
       * @description A list of attachment IDs present on the email. (See [Attachments](https://docs.buttondown.com/api-attachments-introduction) for more information.)
       */
      attachments?: (string)[];
      /** Publish Date */
      publish_date?: string | "none";
      /**
       * Subject 
       * @description The subject line for the email. 
       * @example The subject line for the email
       */
      subject?: string;
      /**
       * Description 
       * @description A human-readable description of the email, used for archives and SEO.
       */
      description?: string;
      /**
       * Canonical Url 
       * @description The URL of the original source of the content. 
       * @example https://sheinhardtwig.com/2025/01/17/our-nbc-partnership
       */
      canonical_url?: string;
      /**
       * Body 
       * @description Can be either HTML or markdown. 
       * @example This is an example of the body of an email.
       */
      body?: string;
      /** @description The type of email to create. Defaults to `PUBLIC`. */
      email_type?: components["schemas"]["EmailType"];
      status?: components["schemas"]["EmailStatus"];
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object.
       */
      metadata?: {
        [key: string]: string | undefined;
      };
      /**
       * Image 
       * @default
       */
      image?: string;
      /**
       * Slug 
       * @example hello-world
       */
      slug?: string;
      /** Secondary Id */
      secondary_id?: number;
      filters?: components["schemas"]["FilterGroup"];
      /** Template */
      template?: components["schemas"]["NewsletterEmailTemplate"] | "none";
      commenting_mode?: components["schemas"]["EmailCommentingMode"];
      /** Related Email Ids */
      related_email_ids?: (string)[];
      /**
       * Featured 
       * @description Designated whether or not this email should be highlighted within the archives. (Currently unused.)
       */
      featured?: boolean;
      /**
       * Should Trigger Pay Per Email Billing 
       * @description Whether this email should trigger pay-per-email billing for paid subscribers. Use this to differentiate between free updates and premium newsletters.
       */
      should_trigger_pay_per_email_billing?: boolean;
    };
    /**
     * AccessLevel 
     * @description An enumeration. 
     * @enum {string}
     */
    AccessLevel: "none" | "read" | "write";
    /** Permissions */
    Permissions: {
      /** @default none */
      subscriber?: components["schemas"]["AccessLevel"];
      /** @default none */
      email?: components["schemas"]["AccessLevel"];
      /** @default none */
      sending?: components["schemas"]["AccessLevel"];
      /** @default none */
      styling?: components["schemas"]["AccessLevel"];
      /** @default none */
      administrivia?: components["schemas"]["AccessLevel"];
      /** @default none */
      automations?: components["schemas"]["AccessLevel"];
      /** @default none */
      surveys?: components["schemas"]["AccessLevel"];
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    InvitationStatus: "pending" | "accepted" | "declined" | "revoked" | "owner";
    /** User */
    User: {
      permissions: components["schemas"]["Permissions"];
      /** Email Address */
      email_address: string;
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      status: components["schemas"]["InvitationStatus"];
      /**
       * Last Logged In 
       * Format: date-time
       */
      last_logged_in?: string;
    };
    /** History */
    History: {
      /** History Id */
      history_id: number;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      /** Value */
      value: string;
      /**
       * User Id 
       * Format: uuid
       */
      user_id?: string;
      user?: components["schemas"]["User"];
    };
    /** Page[History] */
    HistoryPage: {
      /** Results */
      results: (components["schemas"]["History"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** SendDraftInput */
    SendDraftInput: {
      /**
       * Subscribers 
       * @description A list of subscriber ids to which to send the email. 
       * @example [
       *   "bc5601f4-b180-4e02-8501-c18080662376",
       *   "24ee3338-daaf-42b0-bf7b-0cab38972fe5"
       * ]
       */
      subscribers?: (string)[];
      /**
       * Recipients 
       * @description A list of email addresses to send the email to. 
       * @example [
       *   "telemachus@buttondown.email"
       * ]
       */
      recipients?: (string)[];
    };
    /**
     * Type 
     * @description Represents the state of a subscriber and what emails they
     * should or should not be receiving. This type is meant to be fully expressive
     * so as to consolidate the logic of determining what emails a subscriber should
     * receive into a single place.
     * 
     * Note that the only types that can be set programmatically are REGULAR, UNSUBSCRIBED,
     * GIFTED and UNPAID. All other types are meant to be user-visible and cannot
     * be set programmatically. 
     * @enum {string}
     */
    SubscriberType: "regular" | "premium" | "churning" | "past_due" | "gifted" | "unpaid" | "churned" | "unactivated" | "unsubscribed" | "malformed" | "complained" | "undeliverable" | "spammy" | "removed" | "trialed" | "disabled" | "paused" | "disposable" | "blocked";
    /**
     * Source 
     * @description Represents the original provenance of a subscriber. This value is not exposed
     * to subscribers; it's only used for internal tracking purposes and governs some
     * of the behavior of the subscriber (i.e. whether or not to require double
     * opt-in.) 
     * @enum {string}
     */
    SubscriberSource: "api" | "import" | "organic" | "user" | "admin" | "comment" | "stripe";
    /** StripeCoupon */
    StripeCoupon: {
      /** Coupon Id */
      coupon_id: string;
      /** Percent Off */
      percent_off?: string;
      /** Amount Off */
      amount_off?: number;
      /** Name */
      name?: string;
    };
    /**
     * UndeliverabilityReason 
     * @description The reason Buttondown has marked the subscriber as undeliverable.
     * Undeliverable subscribers are not sent emails, and may be periodically removed from the system (or restored, if the reason is no longer valid.) 
     * @enum {string}
     */
    SubscriberUndeliverabilityReason: "email_blocked" | "ip_blocked" | "ip_undeliverable" | "out_of_storage" | "disabled" | "unreachable" | "access_denied" | "does_not_exist" | "rate_limited" | "spam" | "problematic_url" | "on_esp_denylist" | "domain_blocked" | "spf_failed" | "other";
    /** Transition */
    Transition: {
      /**
       * Date 
       * Format: date-time
       */
      date: string;
      type: components["schemas"]["SubscriberType"];
    };
    /**
     * Subscriber 
     * @description Subscribers are the main way you collect email addresses and
     * recipients on Buttondown. They're what you see on your
     * [subscribers page](https://buttondown.com/subscribers).
     * 
     * Relevant changes to the schema:
     * 
     * - [2024-08-01](https://docs.buttondown.com/api-changelog-2024-08-01): renamed `subscriber_type` and `email` to `type` and `email_address` respectively.
     * - [2024-07-13](https://docs.buttondown.com/api-changelog-2024-08-01): removed `external_url` in favor of `absolute_url`.
     */
    Subscriber: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /**
       * Email Address 
       * @description The email address of the subscriber. 
       * @example telemachus@buttondown.email
       */
      email_address: string;
      /**
       * Notes 
       * @description Any notes you want to attach to the subscriber. These are not publicly visible. 
       * @default
       */
      notes?: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
      /** Tags */
      tags: (string)[];
      /**
       * Referrer Url 
       * @default
       */
      referrer_url?: string;
      /** Secondary Id */
      secondary_id: number;
      type: components["schemas"]["SubscriberType"];
      source: components["schemas"]["SubscriberSource"];
      /** Utm Campaign */
      utm_campaign: string;
      /** Utm Medium */
      utm_medium: string;
      /** Utm Source */
      utm_source: string;
      /** Referral Code */
      referral_code: string;
      /** Avatar Url */
      avatar_url?: string;
      stripe_coupon?: components["schemas"]["StripeCoupon"];
      /**
       * Unsubscription Date 
       * Format: date-time
       */
      unsubscription_date?: string;
      /**
       * Churn Date 
       * Format: date-time
       */
      churn_date?: string;
      /**
       * Undeliverability Date 
       * Format: date-time
       */
      undeliverability_date?: string;
      /** @description The reason the subscriber is undeliverable. (Only populated for undeliverable subscribers.) */
      undeliverability_reason?: components["schemas"]["SubscriberUndeliverabilityReason"];
      /**
       * Upgrade Date 
       * Format: date-time
       */
      upgrade_date?: string;
      /** Unsubscription Reason */
      unsubscription_reason?: string;
      /**
       * Transitions 
       * @default []
       */
      transitions?: (components["schemas"]["Transition"])[];
      /** Ip Address */
      ip_address?: string;
      /**
       * Last Open Date 
       * Format: date-time
       */
      last_open_date?: string;
      /**
       * Last Click Date 
       * Format: date-time
       */
      last_click_date?: string;
      /** Stripe Customer Id */
      stripe_customer_id?: string;
      /**
       * Subscriber Import Id 
       * Format: uuid
       */
      subscriber_import_id?: string;
      /**
       * Risk Score 
       * @description The risk score of the subscriber. Positive numbers represent a higher risk; negative numbers represent a lower risk.
       */
      risk_score?: number;
      /** Stripe Customer */
      stripe_customer?: Record<string, unknown>;
    };
    /**
     * ValidationErrorCode 
     * @description Represents the type of error that occurred when validating subscriber input.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    SubscriberInputValidationErrorCode: "email_already_exists" | "email_invalid" | "tag_invalid" | "metadata_invalid" | "ip_address_spammy" | "email_blocked" | "rate_limited" | "subscriber_already_exists" | "subscriber_blocked" | "subscriber_suppressed";
    /** ErrorMessage[ValidationErrorCode] */
    ErrorMessage_ValidationErrorCode_: {
      code: components["schemas"]["SubscriberInputValidationErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** SubscriberInput */
    SubscriberInput: {
      /**
       * Email Address 
       * @example telemachus@buttondown.email
       */
      email_address: string;
      /**
       * Notes 
       * @description Any notes you want to attach to the subscriber. These are not publicly visible. 
       * @default
       */
      notes?: string;
      /**
       * Metadata 
       * @description A structured key-value blob that you can use to store arbitrary data on the object. 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
      /**
       * Tags 
       * @default []
       */
      tags?: (string)[];
      /**
       * Referrer Url 
       * @default
       */
      referrer_url?: string;
      /**
       * Utm Campaign 
       * @default
       */
      utm_campaign?: string;
      /**
       * Utm Medium 
       * @default
       */
      utm_medium?: string;
      /**
       * Utm Source 
       * @default
       */
      utm_source?: string;
      /**
       * Referring Subscriber Id 
       * Format: uuid 
       * @description The ID of the subscriber that referred this subscriber.
       */
      referring_subscriber_id?: string;
      /** @example regular */
      type?: components["schemas"]["SubscriberType"];
      /**
       * Ip Address 
       * @description The IP address of the subscriber. If provided, we will use this IP address to determine the subscriber's location and validate their legitimacy. 
       * @example 127.0.0.1
       */
      ip_address?: string;
    };
    /** Page[Subscriber] */
    SubscriberPage: {
      /** Results */
      results: (components["schemas"]["Subscriber"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * ListSubscribersErrorCode 
     * @description Represents the type of error that occurred when listing subscribers.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    ListSubscribersErrorCode: "invalid_tag" | "date_invalid" | "invalid_ordering";
    /** ErrorMessage[ListSubscribersErrorCode] */
    ErrorMessage_ListSubscribersErrorCode_: {
      code: components["schemas"]["ListSubscribersErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /**
     * UpdateSubscriberErrorCode 
     * @description Represents the type of error that occurred when updating a subscriber.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    UpdateSubscriberErrorCode: "email_already_exists" | "email_invalid" | "email_has_been_changed_too_many_times" | "subscriber_type_invalid" | "tag_invalid";
    /** ErrorMessage[UpdateSubscriberErrorCode] */
    ErrorMessage_UpdateSubscriberErrorCode_: {
      code: components["schemas"]["UpdateSubscriberErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** SubscriberUpdateInput */
    SubscriberUpdateInput: {
      /**
       * Email Address 
       * @example telemachus@buttondown.email
       */
      email_address?: string;
      /**
       * Notes 
       * @description Any notes you want to attach to the subscriber. These are not publicly visible. 
       * @example One of our first subscribers!
       */
      notes?: string;
      /** Metadata */
      metadata?: {
        [key: string]: string | undefined;
      };
      /** Tags */
      tags?: (string)[];
      /**
       * Referrer Url 
       * @default
       */
      referrer_url?: string;
      type?: components["schemas"]["SubscriberType"];
      /** Unsubscription Reason */
      unsubscription_reason?: string;
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    AutomationAttemptStatus: "unprocessed" | "processed" | "failed" | "pending" | "skipped";
    /** AutomationForSubscriber */
    AutomationForSubscriber: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /** Name */
      name: string;
      status: components["schemas"]["AutomationAttemptStatus"];
      /**
       * Automation Id 
       * Format: uuid
       */
      automation_id: string;
      /**
       * Execution Date 
       * Format: date-time
       */
      execution_date: string;
      /** Actions */
      actions: (Record<string, unknown>)[];
    };
    /** Page[AutomationForSubscriber] */
    AutomationForSubscriberPage: {
      /** Results */
      results: (components["schemas"]["AutomationForSubscriber"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** StripeSubscription */
    StripeSubscription: {
      /** Subscription Id */
      subscription_id: string;
      /** Url */
      url: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      /**
       * Ending Date 
       * Format: date-time
       */
      ending_date?: string;
      /** Amount */
      amount: number;
      /** Currency */
      currency: string;
      /** Cadence */
      cadence: string;
      /** Status */
      status: string;
      /**
       * Application Fee Percent 
       * @description The application fee percent for the subscription.
       */
      application_fee_percent?: number;
      /**
       * Source 
       * @description Buttondown attempts to detect the source of a subscription, but this is not always possible. 
       * @enum {string}
       */
      source?: "substack" | "buttondown";
      /**
       * Product 
       * @description The name of the product which the subscriber is subscribed to. (You can override this by setting the `buttondown_template_facing_id` metadata on the product in Stripe.)
       */
      product?: string;
    };
    /** Page[UnexpandableStripeSubscription] */
    StripeSubscriptionPage: {
      /** Results */
      results: (components["schemas"]["StripeSubscription"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Newsletter 
     * @description You will likely not need to interact with your newsletter settings
     * programmatically, but if you do, this is the endpoint for you. You can
     * create, update, and list newsletters via the API; this is ideal for
     * integrating with Buttondown as a headless email or newsletter provider
     * (e.g. for a SaaS product.)
     */
    Newsletter: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /** Username */
      username: string;
      /** Name */
      name: string;
      /**
       * Description 
       * @description A brief description of your newsletter
       */
      description: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      /**
       * Api Key 
       * Format: uuid
       */
      api_key: string;
      /**
       * Tint Color 
       * @default #0069FF
       */
      tint_color?: string;
      /**
       * From Name 
       * @default
       */
      from_name?: string;
      /**
       * Header 
       * @default
       */
      header?: string;
      /**
       * Footer 
       * @default
       */
      footer?: string;
      /**
       * Domain 
       * @default
       */
      domain?: string;
      /**
       * Email Domain 
       * @default
       */
      email_domain?: string;
      /**
       * Enabled Features 
       * @default []
       */
      enabled_features?: (string)[];
      /** Custom Email Template */
      custom_email_template?: string;
      /**
       * Css 
       * @description Custom CSS styling for your newsletter emails 
       * @default
       */
      css?: string;
      /**
       * Web Css 
       * @description Custom CSS styling for your newsletter's web presence 
       * @default
       */
      web_css?: string;
      /**
       * Icon 
       * @description URL to your newsletter's icon image
       */
      icon?: string;
      /**
       * Image 
       * @description URL to your newsletter's header or branding image
       */
      image?: string;
    };
    /** Page[Newsletter] */
    NewsletterPage: {
      /** Results */
      results: (components["schemas"]["Newsletter"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * CreateNewsletterErrorCode 
     * @description Represents the type of error that occurred when creating a newsletter.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    CreateNewsletterErrorCode: "username_already_exists" | "username_malformed";
    /** ErrorMessage[CreateNewsletterErrorCode] */
    ErrorMessage_CreateNewsletterErrorCode_: {
      code: components["schemas"]["CreateNewsletterErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** NewsletterInput */
    NewsletterInput: {
      /**
       * Username 
       * @example sheinhardt
       */
      username: string;
      /**
       * Name 
       * @example Sheinhardt Wig Company
       */
      name: string;
      /**
       * Description 
       * @example Stay up to date with the latest trends in wigs and hairpieces
       */
      description: string;
      /**
       * Tint Color 
       * @default #0069FF
       */
      tint_color?: string;
      /**
       * From Name 
       * @default
       */
      from_name?: string;
      /**
       * Header 
       * @default
       */
      header?: string;
      /**
       * Footer 
       * @default
       */
      footer?: string;
      /**
       * Domain 
       * @default
       */
      domain?: string;
      /**
       * Email Domain 
       * @default
       */
      email_domain?: string;
      /**
       * Enabled Features 
       * @default []
       */
      enabled_features?: (string)[];
      /** Custom Email Template */
      custom_email_template?: string;
      /**
       * Css 
       * @description Custom CSS styling for your newsletter emails. 
       * @default  
       * @example .header { color: #000; }
       */
      css?: string;
      /**
       * Web Css 
       * @description Custom CSS styling for your newsletter's web presence. 
       * @default  
       * @example .container { max-width: 800px; }
       */
      web_css?: string;
      /**
       * Icon 
       * @description URL to your newsletter's icon image. 
       * @default  
       * @example https://example.com/icon.png
       */
      icon?: string;
      /**
       * Image 
       * @description URL to your newsletter's header or branding image. 
       * @default  
       * @example https://example.com/header.jpg
       */
      image?: string;
    };
    /** NewsletterUpdateInput */
    NewsletterUpdateInput: {
      /**
       * Username 
       * @example sheinhardt
       */
      username?: string;
      /**
       * Name 
       * @example Sheinhardt Wig Company
       */
      name?: string;
      /**
       * Description 
       * @example Stay up to date with the latest trends in wigs and hairpieces
       */
      description?: string;
      /** Tint Color */
      tint_color?: string;
      /** From Name */
      from_name?: string;
      /** Header */
      header?: string;
      /** Footer */
      footer?: string;
      /**
       * Domain 
       * @description The domain of the newsletter on which archives are hosted. 
       * @example sheinhardt.com
       */
      domain?: string;
      /**
       * Email Domain 
       * @description The domain of the newsletter from which emails are sent. 
       * @example mail.sheinhardt.com
       */
      email_domain?: string;
      /** Enabled Features */
      enabled_features?: (string)[];
      /** Custom Email Template */
      custom_email_template?: string;
      /**
       * Css 
       * @description Custom CSS styling for your newsletter emails. 
       * @example .header { color: #000; }
       */
      css?: string;
      /**
       * Web Css 
       * @description Custom CSS styling for your newsletter's web presence. 
       * @example .container { max-width: 800px; }
       */
      web_css?: string;
      /**
       * Icon 
       * @description URL to your newsletter's icon image. 
       * @example https://example.com/icon.png
       */
      icon?: string;
      /**
       * Image 
       * @description URL to your newsletter's header or branding image. 
       * @example https://example.com/header.jpg
       */
      image?: string;
    };
    /**
     * Type 
     * @description Represents the action being performed on a bulk of objects.
     * 
     * (Not to be coy, but these names should be self-explanatory.) 
     * @enum {string}
     */
    BulkActionType: "apply_tags" | "apply_metadata" | "ban_subscribers" | "delete_subscribers" | "gift_subscribers" | "ungift_subscribers" | "reactivate_subscribers" | "mark_subscribers_as_not_spammy" | "resubscribe_subscribers" | "send_emails" | "send_reminders" | "unsubscribe_subscribers" | "delete_emails" | "update_email_types" | "update_archival_modes" | "update_commenting_modes" | "delete_tags" | "delete_surveys" | "delete_survey_responses" | "replay_events" | "delete_comments" | "update_survey_statuses" | "modify_stripe_subscriptions";
    /**
     * Status 
     * @description Represents the status of a bulk action.
     * 
     * No action is required to move from one state or another; Buttondown
     * internally handles the transitions, and exposing the status is for
     * observability purposes only. 
     * @enum {string}
     */
    BulkActionStatus: "not_started" | "in_progress" | "processed" | "failed";
    /**
     * BulkAction 
     * @description A bulk action represents, well, a bulk action. It is used to perform
     * actions on a large number of objects at once. For example, you can
     * use it to delete a large number of emails, or to unsubscribe a large
     * number of subscribers. The actions within a bulk action are processed
     * serially by Buttondown; this should be considered an ergonomic way to
     * batch API calls across the network rather than a net-new piece of functionality
     * in of itself.
     */
    BulkAction: {
      /** @example delete_emails */
      type: components["schemas"]["BulkActionType"];
      /**
       * Metadata 
       * @example {
       *   "ids": [
       *     "611c8825-6f21-4544-bb47-9f50453e9cb0",
       *     "418c701a-efe3-4e3d-a404-e635a2f28775"
       *   ]
       * }
       */
      metadata: {
        [key: string]: (string | (string)[] | Record<string, unknown>) | undefined;
      };
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      status: components["schemas"]["BulkActionStatus"];
      /**
       * Completion Date 
       * Format: date-time 
       * @description The date and time at which the bulk action was completed.
       */
      completion_date?: string;
    };
    /** BulkActionInput */
    BulkActionInput: {
      /** @example delete_emails */
      type: components["schemas"]["BulkActionType"];
      /**
       * Metadata 
       * @example {
       *   "ids": [
       *     "611c8825-6f21-4544-bb47-9f50453e9cb0",
       *     "418c701a-efe3-4e3d-a404-e635a2f28775"
       *   ]
       * }
       */
      metadata: {
        [key: string]: (string | (string)[] | Record<string, unknown>) | undefined;
      };
    };
    /**
     * Status 
     * @description Represents the status of the automation, and whether or not it is active. Inactive automations will not be processed. Deleted automations will not be processed. 
     * @enum {string}
     */
    ExternalFeedAutomationStatus: "active" | "failing" | "inactive" | "deleted";
    /**
     * Behavior 
     * @description An enumeration. 
     * @enum {string}
     */
    ExternalFeedAutomationBehavior: "draft" | "emails";
    /**
     * Cadence 
     * @description An enumeration. 
     * @enum {string}
     */
    ExternalFeedAutomationCadence: "every" | "daily" | "weekly" | "monthly";
    /**
     * ExternalFeed 
     * @description An automation is a one-to-one mapping between an external RSS feed and an action
     * to be performed when new items are detected in that feed. Right now, Buttondown offers
     * two actions:
     * 
     * - Send an email
     * - Create an email but save it as a draft to be sent out manually
     * 
     * The automation is configured with a cadence, which is the frequency at which the
     * automation will be run. The cadence can be one of the following:
     * 
     * - Run the automation every time a new item is detected in the feed
     * - Run the automation once per week
     * - Run the automation once per month
     */
    ExternalFeed: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      /**
       * Last Checked Date 
       * Format: date-time
       */
      last_checked_date?: string;
      status: components["schemas"]["ExternalFeedAutomationStatus"];
      behavior: components["schemas"]["ExternalFeedAutomationBehavior"];
      cadence: components["schemas"]["ExternalFeedAutomationCadence"];
      /** Cadence Metadata */
      cadence_metadata: {
        [key: string]: string | undefined;
      };
      filters: components["schemas"]["FilterGroup"];
      /** Url */
      url: string;
      /** Subject */
      subject: string;
      /** Body */
      body: string;
      /** Label */
      label: string;
      /**
       * Metadata 
       * @description Metadata to be passed to emails rendered by this RSS feed. 
       * @example {
       *   "foo": "bar"
       * }
       */
      metadata?: {
        [key: string]: string | undefined;
      };
      /**
       * Skip Old Items 
       * @description Skip items with publish date older than one day from when they're discovered
       */
      skip_old_items: boolean;
    };
    /** ExternalFeedInput */
    ExternalFeedInput: {
      /**
       * Url 
       * @example http://lorem-rss.herokuapp.com/feed
       */
      url: string;
      /** @example draft */
      behavior: components["schemas"]["ExternalFeedAutomationBehavior"];
      /** @example daily */
      cadence: components["schemas"]["ExternalFeedAutomationCadence"];
      /** Cadence Metadata */
      cadence_metadata: {
        [key: string]: string | undefined;
      };
      filters: components["schemas"]["FilterGroup"];
      /** Subject */
      subject: string;
      /** Body */
      body: string;
      /**
       * Label 
       * @default
       */
      label?: string;
      /**
       * Metadata 
       * @description Metadata to be passed to emails rendered by this RSS feed. 
       * @example {
       *   "foo": "bar"
       * }
       */
      metadata?: {
        [key: string]: string | undefined;
      };
      /**
       * Skip Old Items 
       * @description Skip items with publish date older than one day from when they're discovered 
       * @default false
       */
      skip_old_items?: boolean;
    };
    /** Page[ExternalFeed] */
    ExternalFeedPage: {
      /** Results */
      results: (components["schemas"]["ExternalFeed"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** ExternalFeedUpdateInput */
    ExternalFeedUpdateInput: {
      /** @example draft */
      behavior?: components["schemas"]["ExternalFeedAutomationBehavior"];
      /** @example daily */
      cadence?: components["schemas"]["ExternalFeedAutomationCadence"];
      /** Cadence Metadata */
      cadence_metadata?: {
        [key: string]: string | undefined;
      };
      filters?: components["schemas"]["FilterGroup"];
      /** Subject */
      subject?: string;
      /** Body */
      body?: string;
      /** Label */
      label?: string;
      status?: components["schemas"]["ExternalFeedAutomationStatus"];
      /**
       * Metadata 
       * @description Metadata to be passed to emails rendered by this RSS feed. 
       * @example {
       *   "foo": "bar"
       * }
       */
      metadata?: {
        [key: string]: string | undefined;
      };
      /**
       * Skip Old Items 
       * @description Skip items with publish date older than one day from when they're discovered
       */
      skip_old_items?: boolean;
    };
    /**
     * Status 
     * @description The status of a given item (meaning a distinct URL) within an RSS feed. 
     * @enum {string}
     */
    ExternalFeedItemStatus: "unprocessed" | "irrelevant" | "errored" | "skipped" | "queued" | "processed";
    /**
     * ExternalFeedItem 
     * @description An external feed item is a single item in an external RSS feed. It is created
     * automatically by Buttondown when a new item is detected in an external feed. External feed
     * items are immutable and cannot be modified or deleted.
     */
    ExternalFeedItem: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      status: components["schemas"]["ExternalFeedItemStatus"];
      /** Url */
      url: string;
      /**
       * Publish Date 
       * Format: date-time
       */
      publish_date: string;
      /** Title */
      title: string;
      /** Description */
      description: string;
      /** Content */
      content: string;
      /** Author */
      author: string;
      /**
       * Email Id 
       * Format: uuid
       */
      email_id?: string;
      email?: components["schemas"]["Email"];
    };
    /** Page[ExternalFeedItem] */
    ExternalFeedItemPage: {
      /** Results */
      results: (components["schemas"]["ExternalFeedItem"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    AutomationStatus: "active" | "inactive";
    /**
     * Type 
     * @description Various types of events that are recorded by Buttondown, both in terms of exogenous systems
     * like Stripe and Memberful, and endogenous ones like email opens and clicks. (In general, if anything
     * important ever happens that could be relevant to your newsletter, we have an event type for it!)
     * 
     * These event types power lots of things within Buttondown. They're used to trigger automations, webhooks,
     * and analytics.
     * 
     * (Note that Buttondown also has a different thing we call "events"; those are `EmailEvents` and are used
     * for tracking aggregate details about an email. Alas, we shouldn't have used the term "event" for two different
     * things, but it's too late to go back now!)
     * 
     * In general, our event namespacing tries to hew to the following pattern:
     * 
     * <source>.<object>.<action>
     * 
     * When wondering which object we are referring to, default to the _more granular_ object.
     * 
     * For instance, an email being sent to a subscriber is `subscriber.delivered`, not `email.sent`. 
     * @enum {string}
     */
    ExternalEventType: "subscriber.created" | "subscriber.unsubscribed" | "subscriber.changed_email" | "subscriber.confirmed" | "subscriber.trial_started" | "subscriber.trial_ended" | "subscriber.type.changed" | "subscriber.tags.changed" | "subscriber.clicked" | "subscriber.opened" | "subscriber.paid" | "subscriber.churned" | "subscriber.updated" | "subscriber.deleted" | "subscriber.viewed_checkout_page" | "subscriber.replied" | "subscriber.paused" | "subscriber.resumed" | "subscriber.responded_to_survey" | "subscriber.referred" | "subscriber.referred.paid" | "subscriber.commented" | "subscriber.delivered" | "subscriber.complained" | "subscriber.bounced" | "subscriber.rejected" | "survey.created" | "survey.updated" | "survey.deleted" | "survey.cleared_responses" | "email.created" | "email.sent" | "email.updated" | "email.deleted" | "email.status.changed" | "mention.created" | "advertising_slot.purchased" | "social_mention.created" | "export.created" | "export.completed" | "export.failed" | "automation.invoked" | "stripe.checkout.session.completed" | "stripe.subscription.activated" | "stripe.subscription.churning" | "stripe.subscription.deactivated" | "stripe.customer.updated" | "memberful.subscription.created" | "memberful.subscription.deleted" | "memberful.member.updated" | "date.day.started" | "date.week.started" | "date.month.started" | "date.year.started" | "firewall.blocked" | "patreon.membership.created" | "patreon.membership.deleted" | "patreon.member.updated" | "note.created" | "note.deleted" | "external_feed_item.created" | "shopify.customer.created" | "shopify.customer.updated";
    /** Delay */
    Delay: {
      /** Value */
      value: string;
      /**
       * Unit 
       * @enum {string}
       */
      unit: "minutes" | "hours" | "days" | "weeks";
      /**
       * Time Of Day 
       * @enum {string}
       */
      time_of_day?: "morning" | "evening" | "";
    };
    /** Timing */
    Timing: {
      /**
       * Time 
       * @enum {string}
       */
      time: "immediate" | "delay";
      delay?: components["schemas"]["Delay"];
    };
    /**
     * ActionType 
     * @description The action that is triggered when the automation is successfully run. 
     * @enum {string}
     */
    AutomationActionType: "add_tags" | "remove_tags" | "send_email" | "add_metadata" | "change_email_address" | "gift_premium_subscription" | "ungift_premium_subscription" | "send_discord_invitation" | "send_github_invitation" | "create_subscriber" | "unsubscribe_subscriber" | "shopify_unsubscribe" | "shopify_resubscribe" | "shopify_set_tags" | "shopify_create_customer" | "send_notification" | "forward_reply" | "create_linkedin_post" | "create_twitter_post" | "create_tumblr_post" | "create_bluesky_post" | "create_arena_post" | "create_export" | "send_post_request";
    /** Action */
    Action: {
      type: components["schemas"]["AutomationActionType"];
      /** Metadata */
      metadata: Record<string, unknown>;
    };
    /** Automation */
    Automation: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      /** Name */
      name: string;
      status: components["schemas"]["AutomationStatus"];
      trigger: components["schemas"]["ExternalEventType"];
      timing: components["schemas"]["Timing"];
      /** Actions */
      actions: (components["schemas"]["Action"])[];
      filters: components["schemas"]["FilterGroup"];
      /** Metadata */
      metadata: {
        [key: string]: string | undefined;
      };
    };
    /** Page[Automation] */
    AutomationPage: {
      /** Results */
      results: (components["schemas"]["Automation"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * AutomationCreationErrorCode 
     * @description Represents the type of error that occurred when creating an automation.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    AutomationCreationErrorCode: "delay_invalid" | "filter_invalid__tag" | "filter_invalid" | "action_invalid" | "invalid_newsletter_id" | "action_invalid__missing_body_or_subject";
    /** ErrorMessage[AutomationCreationErrorCode] */
    ErrorMessage_AutomationCreationErrorCode_: {
      code: components["schemas"]["AutomationCreationErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** AutomationInput */
    AutomationInput: {
      /** Name */
      name: string;
      trigger: components["schemas"]["ExternalEventType"];
      timing: components["schemas"]["Timing"];
      /** Actions */
      actions: (Record<string, unknown>)[];
      filters: components["schemas"]["FilterGroup"];
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** SubscriberForAutomation */
    SubscriberForAutomation: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      status: components["schemas"]["AutomationAttemptStatus"];
      /** Subscriber Id */
      subscriber_id?: string;
      subscriber?: components["schemas"]["Subscriber"];
    };
    /** Page[SubscriberForAutomation] */
    SubscriberForAutomationPage: {
      /** Results */
      results: (components["schemas"]["SubscriberForAutomation"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** AutomationUpdateInput */
    AutomationUpdateInput: {
      /** Name */
      name?: string;
      status?: components["schemas"]["AutomationStatus"];
      trigger?: components["schemas"]["ExternalEventType"];
      timing?: components["schemas"]["Timing"];
      /** Actions */
      actions?: (Record<string, unknown>)[];
      filters?: components["schemas"]["FilterGroup"];
      /** Metadata */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /**
     * Failure 
     * @description An enumeration. 
     * @enum {string}
     */
    Failure: "email_already_exists";
    /** ErrorMessage[Failure] */
    ErrorMessage_Failure_: {
      code: components["schemas"]["Failure"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** UserInput */
    UserInput: {
      permissions: components["schemas"]["Permissions"];
      /** Email Address */
      email_address: string;
    };
    /** Page[User] */
    UserPage: {
      /** Results */
      results: (components["schemas"]["User"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** UserUpdateInput */
    UserUpdateInput: {
      /** Permissions */
      permissions: {
        [key: string]: string | undefined;
      };
    };
    /** Product */
    Product: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /** Product Id */
      product_id: string;
      /** Name */
      name: string;
      /** Creation Date */
      creation_date: string;
      /** Active */
      active: boolean;
    };
    /** Price */
    Price: {
      /**
       * Style 
       * @enum {string}
       */
      style: "pay-what-you-want" | "fixed" | "usage-based";
      /** Amount */
      amount?: number;
      /** Currency */
      currency: string;
      /**
       * Cadence 
       * @enum {string}
       */
      cadence: "year" | "month" | "one-time" | "email" | "week";
      /** Product Id */
      product_id?: string;
      /** Id */
      id: string;
      product?: components["schemas"]["Product"];
    };
    /** Page[Price] */
    PricePage: {
      /** Results */
      results: (components["schemas"]["Price"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * ListPricesErrorCode 
     * @description Represents the type of error that occurred when listing a price.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    ListPricesErrorCode: "paid_subscriptions_uninitialized";
    /** ErrorMessage[ListPricesErrorCode] */
    ErrorMessage_ListPricesErrorCode_: {
      code: components["schemas"]["ListPricesErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /**
     * CreatePriceErrorCode 
     * @description Represents the type of error that occurred when listing a price.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    CreatePriceErrorCode: "paid_subscriptions_uninitialized" | "invalid_amount";
    /** ErrorMessage[CreatePriceErrorCode] */
    ErrorMessage_CreatePriceErrorCode_: {
      code: components["schemas"]["CreatePriceErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** PriceInput */
    PriceInput: {
      /**
       * Style 
       * @enum {string}
       */
      style: "pay-what-you-want" | "fixed" | "usage-based";
      /** Amount */
      amount?: number;
      /** Currency */
      currency: string;
      /**
       * Cadence 
       * @enum {string}
       */
      cadence: "year" | "month" | "one-time" | "email" | "week";
      /** Product Id */
      product_id?: string;
    };
    /** Page[StripeCoupon] */
    StripeCouponPage: {
      /** Results */
      results: (components["schemas"]["StripeCoupon"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * ResponseCadence 
     * @description An enumeration. 
     * @enum {string}
     */
    SurveyResponseCadence: "once" | "once_per_email";
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    SurveyStatus: "active" | "inactive";
    /** Survey */
    Survey: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /** Identifier */
      identifier: string;
      /** Question */
      question: string;
      /** Response Count */
      response_count: number;
      /** Answers */
      answers: (string)[];
      /** Notes */
      notes: string;
      response_cadence: components["schemas"]["SurveyResponseCadence"];
      status: components["schemas"]["SurveyStatus"];
      /** Is Freeform Response Enabled */
      is_freeform_response_enabled: boolean;
    };
    /**
     * CreateSurveyErrorCode 
     * @description Represents the type of error that occurred when creating a survey.
     * 
     * Human-readable error messages are provided in the `detail` field of the response;
     * these values are meant to be parseable by code or client logic. 
     * @enum {string}
     */
    CreateSurveyErrorCode: "identifier_already_exists";
    /** ErrorMessage[CreateSurveyErrorCode] */
    ErrorMessage_CreateSurveyErrorCode_: {
      code: components["schemas"]["CreateSurveyErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** SurveyInput */
    SurveyInput: {
      /**
       * Identifier 
       * @example color
       */
      identifier: string;
      /**
       * Question 
       * @example What's your favorite color?
       */
      question: string;
      /**
       * Answers 
       * @example [
       *   "Red",
       *   "Green",
       *   "Blue"
       * ]
       */
      answers: (string)[];
      /**
       * Notes 
       * @default  
       * @example
       */
      notes?: string;
      /**
       * Is Freeform Response Enabled 
       * @default false 
       * @example false
       */
      is_freeform_response_enabled?: boolean;
      /**
       * @default once 
       * @example once
       */
      response_cadence?: components["schemas"]["SurveyResponseCadence"];
    };
    /** Page[Survey] */
    SurveyPage: {
      /** Results */
      results: (components["schemas"]["Survey"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * UpdateSurveyErrorCode 
     * @description An enumeration. 
     * @enum {string}
     */
    UpdateSurveyErrorCode: "answers_empty";
    /** ErrorMessage[UpdateSurveyErrorCode] */
    ErrorMessage_UpdateSurveyErrorCode_: {
      code: components["schemas"]["UpdateSurveyErrorCode"];
      /** Detail */
      detail: string;
      /**
       * Metadata 
       * @default {}
       */
      metadata?: {
        [key: string]: string | undefined;
      };
    };
    /** SurveyUpdateInput */
    SurveyUpdateInput: {
      /** Notes */
      notes?: string;
      /**
       * Answers 
       * @example [
       *   "Red",
       *   "Green",
       *   "Blue"
       * ]
       */
      answers?: (string)[];
      /** @example once */
      response_cadence?: components["schemas"]["SurveyResponseCadence"];
      status?: components["schemas"]["SurveyStatus"];
      /**
       * Is Freeform Response Enabled 
       * @default false
       */
      is_freeform_response_enabled?: boolean;
    };
    /**
     * Source 
     * @description An enumeration. 
     * @enum {string}
     */
    APIRequestSource: "api" | "app" | "carrd" | "zapier" | "cli" | "make";
    /**
     * APIRequestDetail 
     * @description Represents a request to the API (api.buttondown.com).
     */
    APIRequestDetail: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /** Status Code */
      status_code: number;
      /** Path */
      path: string;
      /** Method */
      method: string;
      source: components["schemas"]["APIRequestSource"];
      /**
       * Version 
       * @enum {string}
       */
      version: "2024-07-01" | "2024-08-01" | "2024-08-15" | "2024-09-30" | "2024-12-30" | "2025-01-02" | "2025-05-19" | "2025-06-01";
      /** Request Data */
      request_data: string;
      /** Response Data */
      response_data: string;
      /** Ip Address */
      ip_address: string;
    };
    /**
     * APIRequest 
     * @description Represents a request to the API (api.buttondown.com).
     */
    APIRequest: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /** Status Code */
      status_code: number;
      /** Path */
      path: string;
      /** Method */
      method: string;
      source: components["schemas"]["APIRequestSource"];
      /**
       * Version 
       * @enum {string}
       */
      version: "2024-07-01" | "2024-08-01" | "2024-08-15" | "2024-09-30" | "2024-12-30" | "2025-01-02" | "2025-05-19" | "2025-06-01";
    };
    /** APIRequestList */
    APIRequestList: {
      /** Results */
      results: (components["schemas"]["APIRequest"])[];
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    AdvertisingSKUStatus: "active" | "inactive";
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    AdvertisingSlotStatus: "open" | "sold" | "finalized" | "executed" | "expired";
    /** AdvertisingSlot */
    AdvertisingSlot: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /**
       * Date 
       * Format: date
       */
      date: string;
      status: components["schemas"]["AdvertisingSlotStatus"];
      /** Invoice Url */
      invoice_url?: string;
      /** Content */
      content: string;
    };
    /** AdvertisingUnit */
    AdvertisingUnit: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      status: components["schemas"]["AdvertisingSKUStatus"];
      /** Slots */
      slots: (components["schemas"]["AdvertisingSlot"])[];
      /** Title */
      title: string;
      /** Description */
      description: string;
      /** Behavior */
      behavior: string;
      /** Url */
      url: string;
      /** Price */
      price?: number;
    };
    /** Page[AdvertisingUnit] */
    AdvertisingUnitPage: {
      /** Results */
      results: (components["schemas"]["AdvertisingUnit"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** AdvertisingUnitInput */
    AdvertisingUnitInput: {
      /** Title */
      title?: string;
      /** Description */
      description?: string;
      /**
       * Behavior 
       * @default
       */
      behavior?: string;
      /**
       * Url 
       * @default
       */
      url?: string;
      /** Price */
      price?: number;
    };
    /** AdvertisingUnitUpdateInput */
    AdvertisingUnitUpdateInput: {
      /** Title */
      title?: string;
      /** Description */
      description?: string;
      /** Dates */
      dates: (string)[];
      /** Behavior */
      behavior?: string;
      /** Url */
      url?: string;
      /** Price */
      price?: number;
    };
    /** AdvertisingSlotUpdateInput */
    AdvertisingSlotUpdateInput: {
      /** Content */
      content?: string;
    };
    /**
     * WebhookStatus 
     * @description The status of a webhook. 
     * @enum {string}
     */
    WebhookStatus: "enabled" | "disabled";
    /**
     * Webhook 
     * @description Webhooks are used to notify external services of events that occur in the
     * system. For example, when a newsletter is sent, a webhook can be used to
     * notify an external service that the newsletter has been sent.
     */
    Webhook: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /**
       * @description Whether the webhook is enabled or not. 
       * @default enabled 
       * @example enabled
       */
      status?: components["schemas"]["WebhookStatus"];
      /**
       * @description The types of event for which the webhook will be triggered. 
       * @example [
       *   "email.created",
       *   "email.sent"
       * ]
       */
      event_types: (components["schemas"]["ExternalEventType"])[];
      /**
       * Url 
       * Format: uri 
       * @description The URL to which the webhook will send POST requests. 
       * @example https://my.api/webhook
       */
      url: string;
      /**
       * Description 
       * @description An optional description of the webhook, for reference. 
       * @default  
       * @example Trigger when an email is created to notify in Slack.
       */
      description?: string;
    };
    /** WebhookInput */
    WebhookInput: {
      /**
       * @description Whether the webhook is enabled or not. 
       * @default enabled 
       * @example enabled
       */
      status?: components["schemas"]["WebhookStatus"];
      /**
       * @description The types of event for which the webhook will be triggered. 
       * @example [
       *   "email.created",
       *   "email.sent"
       * ]
       */
      event_types: (components["schemas"]["ExternalEventType"])[];
      /**
       * Url 
       * Format: uri 
       * @description The URL to which the webhook will send POST requests. 
       * @example https://my.api/webhook
       */
      url: string;
      /**
       * Description 
       * @description An optional description of the webhook, for reference. 
       * @default  
       * @example Trigger when an email is created to notify in Slack.
       */
      description?: string;
    };
    /** Page[Webhook] */
    WebhookPage: {
      /** Results */
      results: (components["schemas"]["Webhook"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Status 
     * @description An enumeration. 
     * @enum {string}
     */
    WebhookAttemptStatus: "unattempted" | "successful" | "failed";
    /** WebhookAttemptOutput */
    WebhookAttemptOutput: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /**
       * @description The status of the webhook attempt. 
       * @example successful
       */
      status: components["schemas"]["WebhookAttemptStatus"];
    };
    /** Page[WebhookAttemptOutput] */
    WebhookAttemptOutputPage: {
      /** Results */
      results: (components["schemas"]["WebhookAttemptOutput"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /**
     * Comment 
     * @description Comments are a way for subscribers to interact with newsletters. They're a way to
     * provide feedback, ask questions, and generally engage with the content of an email.
     * Comments exist in a tree structure; comments that reply to other comments are
     * considered "children" of the parent comment.
     */
    Comment: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /**
       * Email Id 
       * Format: uuid
       */
      email_id: string;
      /**
       * Subscriber Id 
       * Format: uuid
       */
      subscriber_id?: string;
      /**
       * Parent Id 
       * Format: uuid 
       * @description The ID of the parent comment, if this comment is a reply to another comment.
       */
      parent_id?: string;
      /** Text */
      text: string;
      subscriber?: components["schemas"]["Subscriber"];
      email?: components["schemas"]["Email"];
    };
    /** Page[Comment] */
    CommentPage: {
      /** Results */
      results: (components["schemas"]["Comment"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** Response */
    Response: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /**
       * Answer 
       * @description The answer given to the survey.
       */
      answer: string;
      /**
       * Text 
       * @description Optional text included by the subscriber with the response. Subscribers are only prompted to supply a text response if the `is_freeform_response_enabled` field is set to `true` on the survey.
       */
      text: string;
      /**
       * Survey Id 
       * Format: uuid
       */
      survey_id: string;
      /**
       * Subscriber Id 
       * Format: uuid
       */
      subscriber_id: string;
      /**
       * Email Id 
       * Format: uuid
       */
      email_id?: string;
      /**
       * Automation Id 
       * Format: uuid
       */
      automation_id?: string;
      subscriber?: components["schemas"]["Subscriber"];
      survey?: components["schemas"]["Survey"];
      email?: components["schemas"]["Email"];
      automation?: components["schemas"]["Automation"];
    };
    /** Page[Response] */
    ResponsePage: {
      /** Results */
      results: (components["schemas"]["Response"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** ResponseInput */
    ResponseInput: {
      /**
       * Subscriber Id 
       * Format: uuid
       */
      subscriber_id: string;
      /**
       * Survey Id 
       * Format: uuid
       */
      survey_id: string;
      /** Email Id */
      email_id: string;
      /** Answer */
      answer: number;
    };
    /**
     * EmailEventType 
     * @description An enumeration. 
     * @enum {string}
     */
    EmailEventType: "activation_clicked" | "activation_delivered" | "activation_opened" | "bounced" | "complained" | "clicked" | "dropped" | "delivered" | "opened" | "sent" | "rejected" | "replied" | "unsubscribed";
    /** EmailEvent */
    EmailEvent: {
      /**
       * Id 
       * Format: uuid
       */
      id: string;
      /**
       * Subscriber Id 
       * Format: uuid
       */
      subscriber_id?: string;
      /**
       * Email Id 
       * Format: uuid
       */
      email_id?: string;
      /**
       * Automation Id 
       * Format: uuid
       */
      automation_id?: string;
      /**
       * Creation Date 
       * Format: date-time
       */
      creation_date: string;
      /** Metadata */
      metadata: {
        [key: string]: string | undefined;
      };
      event_type: components["schemas"]["EmailEventType"];
      subscriber?: components["schemas"]["Subscriber"];
      email?: components["schemas"]["Email"];
      automation?: components["schemas"]["Automation"];
    };
    /** Page[EmailEvent] */
    EmailEventPage: {
      /** Results */
      results: (components["schemas"]["EmailEvent"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** Note */
    Note: {
      /**
       * Id 
       * Format: uuid 
       * @description A unique UUID associated with the object.
       */
      id: string;
      /**
       * Creation Date 
       * Format: date-time 
       * @description The date and time at which the object was created.
       */
      creation_date: string;
      /** Body */
      body: string;
      /** Model Type */
      model_type: string;
      /** Model Id */
      model_id: string;
      /** Metadata */
      metadata: Record<string, unknown>;
      /**
       * User Id 
       * Format: uuid
       */
      user_id: string;
      user?: components["schemas"]["User"];
    };
    /** NoteInput */
    NoteInput: {
      /**
       * Body 
       * @description The text content of the note.
       */
      body: string;
      /**
       * Model Type 
       * @description The type of object this note is attached to (e.g., 'email', 'subscriber').
       */
      model_type: string;
      /**
       * Model Id 
       * @description The ID of the object this note is attached to.
       */
      model_id: string;
      /**
       * Metadata 
       * @description Arbitrary metadata as key-value pairs.
       */
      metadata?: Record<string, unknown>;
    };
    /** Page[Note] */
    NotePage: {
      /** Results */
      results: (components["schemas"]["Note"])[];
      /** Next */
      next?: string;
      /** Previous */
      previous?: string;
      /** Count */
      count: number;
    };
    /** @enum {string} */
    EmailExcludableField: "body";
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /** List Exports */
  list_exports: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExportPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Export */
  create_export: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExportInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Export"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_CreateExportErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Export 
   * @description Retrieve a specific export by its ID
   */
  retrieve_export: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Export"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Tags */
  list_tags: {
    parameters: {
      query: {
        /** @description If provided, only return tags matching the given IDs. */
        ids?: (string)[];
        page_size?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["TagPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Tag */
  create_tag: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Tag"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Tag 
   * @description Retrieve a specific tag by its ID
   */
  retrieve_tag: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Tag"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Tag 
   * @description Delete a tag
   */
  delete_tag: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Tag 
   * @description Update a tag's properties
   */
  update_tag: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Tag"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_UpdateTagErrorCode_"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Tag Analytics 
   * @description Retrieve analytics for a specific tag
   */
  retrieve_tag_analytics: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["TagAnalytics"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Ping */
  ping: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Empty"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Get Account */
  get_account: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Account"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Images */
  list_images: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ImagePage"];
        };
      };
    };
  };
  /** Create Image */
  create_image: {
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Image 
           * Format: binary
           */
          image: string;
        };
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Image"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Image 
   * @description Delete an uploaded image
   */
  delete_image: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Attachments */
  list_attachments: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AttachmentPage"];
        };
      };
    };
  };
  /** Create Attachment */
  create_attachment: {
    parameters: {
      query: {
        name?: string;
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * File 
           * Format: binary
           */
          file: string;
        };
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Attachment"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Attachment 
   * @description Delete an attachment
   */
  delete_attachment: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Emails */
  list_emails: {
    parameters: {
      query: {
        /** @description If provided, only return emails with the given status. */
        status?: (components["schemas"]["EmailStatus"])[];
        /** @description If provided, only return emails without the given status. */
        negative_status?: (components["schemas"]["EmailStatus"])[];
        automations?: (string)[];
        /** @description If provided, only return emails with the given ids. */
        ids?: (string)[];
        ordering?: "creation_date" | "-creation_date" | "status" | "-status" | "publish_date" | "-publish_date" | "subject" | "-subject" | "email_type" | "-email_type" | "modification_date" | "-modification_date" | "clicks" | "-clicks" | "opens" | "-opens" | "click_rate" | "-click_rate" | "open_rate" | "-open_rate" | "page_views__lifetime" | "-page_views__lifetime" | "page_views__30" | "-page_views__30" | "page_views__7" | "-page_views__7" | "webmentions" | "-webmentions" | "subscriptions" | "-subscriptions" | "paid_subscriptions" | "-paid_subscriptions" | "unsubscriptions" | "-unsubscriptions" | "replies" | "-replies" | "comments" | "-comments" | "social_mentions" | "-social_mentions" | "permanent_failure_rate" | "-permanent_failure_rate" | "complaint_rate" | "-complaint_rate";
        /** @description If provided, only return emails created after the given date. */
        creation_date__start?: string;
        /** @description If provided, only return emails created before the given date. */
        creation_date__end?: string;
        /** @description If provided, only return emails published after the given date. */
        publish_date__start?: string;
        /** @description If provided, only return emails published before the given date. */
        publish_date__end?: string;
        excluded_fields?: (components["schemas"]["EmailExcludableField"])[];
        source?: (components["schemas"]["EmailSource"])[];
        /** @description The type of emails to return. Defaults to all types. */
        email_type?: (components["schemas"]["EmailType"])[];
        /** @description If provided, only return emails with a subject that contains the given string. */
        subject?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["EmailPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_EmailListErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: never;
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Email */
  create_email: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["EmailInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Email"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_EmailCreationErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Email 
   * @description Retrieve a specific email by its ID
   */
  retrieve_email: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Email"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Email 
   * @description Update an email's properties
   */
  update_email: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EmailUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Email"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Email History 
   * @description Retrieve the edit history for a specific email
   */
  retrieve_email_history: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. */
        expand?: ("user")[];
        field: string;
        page?: number;
        ordering?: "creation_date" | "-creation_date";
        query?: string;
        page_size?: number;
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["HistoryPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Email History By Id 
   * @description Retrieve a specific historical version of an email's body
   */
  retrieve_email_history_by_id: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. */
        expand?: ("user")[];
      };
      path: {
        id: string;
        history_id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["History"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Email Analytics 
   * @description Retrieve analytics for a specific email
   */
  retrieve_email_analytics: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Analytics"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Send Draft 
   * @description Send a draft email to specific recipients
   */
  send_draft: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendDraftInput"];
      };
    };
    responses: {
      /** @description OK */
      200: never;
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Subscribers */
  list_subscribers: {
    parameters: {
      query: {
        /** @description If provided, only return subscribers with the given type. */
        type?: (components["schemas"]["SubscriberType"])[];
        /** @description If provided, only return subscribers without the given type. */
        "-type"?: (components["schemas"]["SubscriberType"])[];
        /** @description If provided, only return subscribers with the given IDs. */
        ids?: (string)[];
        /** @description If provided, only return subscribers whose email address contains the given string. */
        email_address?: string;
        tag?: (string)[];
        "-tag"?: string;
        ordering?: string;
        /** @description If provided, only return subscribers with the given price ID(s). */
        price?: (string)[];
        /** @description If provided, only return subscribers with the given coupon ID(s). */
        coupon?: (string)[];
        /** @description If provided, only return subscribers with the given referral code(s). */
        referral_code?: (string)[];
        /** @description If provided, only return subscribers created on or after the given date. */
        date__start?: string;
        /** @description If provided, only return subscribers created before the given date. */
        date__end?: string;
        /** @description If provided, only return subscribers with the given last open date(s). */
        last_open_date__start?: string;
        /** @description If provided, only return subscribers with the given last open date(s). */
        last_open_date__end?: string;
        /** @description If provided, only return subscribers with the given last click date(s). */
        last_click_date__start?: string;
        /** @description If provided, only return subscribers with the given last click date(s). */
        last_click_date__end?: string;
        /** @description If provided, only return subscribers that were imported by the given subscriber import. */
        subscriber_import?: (string)[];
        /** @description If provided, expand the given field. (Only supported fields: 'stripe_customer') */
        expand?: ("stripe_customer")[];
        /** @description If provided, only return subscribers with the given IP address(es). */
        ip_address?: (string)[];
        /** @description If provided, only return subscribers with the given upgrade date(s). */
        upgrade_date__start?: string;
        /** @description If provided, only return subscribers with the given upgrade date(s). */
        upgrade_date__end?: string;
        /** @description If provided, only return subscribers with the given undeliverability date(s). */
        undeliverability_date__start?: string;
        /** @description If provided, only return subscribers with the given undeliverability date(s). */
        undeliverability_date__end?: string;
        /** @description If provided, only return subscribers with the given undeliverability reason(s). */
        undeliverability_reason?: (components["schemas"]["SubscriberUndeliverabilityReason"])[];
        /** @description If provided, only return subscribers with the given unsubscription reason(s). */
        unsubscription_reason?: (string)[];
        /** @description If provided, only return subscribers with the given referrer URL(s). */
        referrer_url?: (string)[];
        /** @description If provided, only return subscribers with the given UTM source(s). */
        utm_source?: (string)[];
        /** @description If provided, only return subscribers with the given UTM campaign(s). */
        utm_campaign?: (string)[];
        /** @description If provided, only return subscribers with the given UTM medium(s). */
        utm_medium?: (string)[];
        /** @description If provided, only return subscribers whose email domain matches the given domain(s). */
        domain?: (string)[];
        /** @description If provided, only return subscribers whose email domain does not match the given domain(s). */
        "-domain"?: (string)[];
        /** @description If provided, only return subscribers with a risk score greater than or equal to the given value. */
        risk_score__start?: number;
        /** @description If provided, only return subscribers with a risk score less than or equal to the given value. */
        risk_score__end?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SubscriberPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_ListSubscribersErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /** Create Subscriber */
  create_subscriber: {
    parameters: {
      header: {
        /**
         * @description The behavior to apply when a subscriber with the same email address already exists.
         * Defaults to "no_op", which will return a 400 error if a subscriber with the same email address already exists. Other values include:
         * 
         * - "overwrite", which will overwrite the existing subscriber's data with the new one.
         * - "add", which will add the new subscriber data to the existing one.
         */
        "X-Buttondown-Collision-Behavior"?: "no_op" | "add" | "overwrite" | "fail";
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SubscriberInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Subscriber"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_ValidationErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Retrieve Subscriber */
  retrieve_subscriber: {
    parameters: {
      query: {
        expand?: ("stripe_customer")[];
      };
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Subscriber"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Delete Subscriber */
  delete_subscriber: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Update Subscriber */
  update_subscriber: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SubscriberUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Subscriber"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_UpdateSubscriberErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Send Reminder */
  send_reminder: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Send Email To */
  send_email_to: {
    parameters: {
      path: {
        id_or_email: string;
        email_id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Empty"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Get Referrals */
  get_referrals: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SubscriberPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Get Automations */
  get_automations: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AutomationForSubscriberPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Get Stripe Subscriptions */
  get_stripe_subscriptions: {
    parameters: {
      path: {
        id_or_email: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["StripeSubscriptionPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Newsletters */
  list_newsletters: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["NewsletterPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Newsletter */
  create_newsletter: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewsletterInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Newsletter"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_CreateNewsletterErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Newsletter 
   * @description Delete a newsletter
   */
  delete_newsletter: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Newsletter 
   * @description Update a newsletter's settings
   */
  update_newsletter: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewsletterUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Newsletter"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Bulk Action */
  create_bulk_action: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["BulkActionInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["BulkAction"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Bulk Action 
   * @description Retrieve the status of a bulk action
   */
  retrieve_bulk_action: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["BulkAction"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List External Feed */
  list_external_feed: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalFeedPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create External Feed */
  create_external_feed: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExternalFeedInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["ExternalFeed"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve External Feed 
   * @description Retrieve a specific external feed by its ID
   */
  retrieve_external_feed: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalFeed"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete External Feed 
   * @description Delete an external feed
   */
  delete_external_feed: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update External Feed 
   * @description Update an external feed's properties
   */
  update_external_feed: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExternalFeedUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalFeed"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Items 
   * @description Retrieve items from an external feed
   */
  retrieve_items: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. */
        expand?: ("email")[];
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalFeedItemPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Poll Items 
   * @description Poll for new items in an external feed
   */
  poll_items: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Empty"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Automations */
  list_automations: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AutomationPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Automation */
  create_automation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Automation"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_AutomationCreationErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Automation Subscribers 
   * @description Retrieve subscribers associated with an automation
   */
  retrieve_automation_subscribers: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. (Only supported field: 'subscriber'). */
        expand?: ("subscriber")[];
        page?: number;
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SubscriberForAutomationPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Automation 
   * @description Retrieve a specific automation by its ID
   */
  retrieve_automation: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Automation"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Automation 
   * @description Delete an automation
   */
  delete_automation: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Automation 
   * @description Update an automation's properties
   */
  update_automation: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Automation"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Invoke Automation 
   * @description Manually trigger an automation
   */
  invoke_automation: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Automation Analytics 
   * @description Retrieve analytics data for an automation
   */
  retrieve_automation_analytics: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Analytics"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Users */
  list_users: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UserPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create User */
  create_user: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_Failure_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve User 
   * @description Retrieve a specific user by its ID
   */
  retrieve_user: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete User 
   * @description Delete a user
   */
  delete_user: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update User 
   * @description Update a user's properties
   */
  update_user: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Prices */
  list_prices: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. */
        expand?: ("product")[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["PricePage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_ListPricesErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Price */
  create_price: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PriceInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Price"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_CreatePriceErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Coupons */
  list_coupons: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["StripeCouponPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Surveys */
  list_surveys: {
    parameters: {
      query: {
        /** @description If provided, only return surveys with the given status. */
        status?: (components["schemas"]["SurveyStatus"])[];
        /** @description If provided, only return surveys without the given status. */
        "-status"?: (components["schemas"]["SurveyStatus"])[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SurveyPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Survey */
  create_survey: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SurveyInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Survey"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_CreateSurveyErrorCode_"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Survey 
   * @description Retrieve a specific survey by its ID
   */
  retrieve_survey: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Survey"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Survey 
   * @description Delete a survey
   */
  delete_survey: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Survey 
   * @description Update a survey's properties
   */
  update_survey: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SurveyUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Survey"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage_UpdateSurveyErrorCode_"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Api Request 
   * @description Retrieve a specific API request by its ID
   */
  retrieve_api_request: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["APIRequestDetail"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Api Requests */
  list_api_requests: {
    parameters: {
      query: {
        status_code?: (string)[];
        method?: (string)[];
        source?: (components["schemas"]["APIRequestSource"])[];
        version?: ("2024-07-01" | "2024-08-01" | "2024-08-15" | "2024-09-30" | "2024-12-30" | "2025-01-02" | "2025-05-19" | "2025-06-01")[];
        date__start?: string;
        date__end?: string;
        creation_date__lt?: string;
        creation_date__gt?: string;
        path?: (string)[];
        limit?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["APIRequestList"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Advertising Units */
  list_advertising_units: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AdvertisingUnitPage"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Advertising Unit */
  create_advertising_unit: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdvertisingUnitInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["AdvertisingUnit"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Advertising Unit 
   * @description Delete an advertising unit
   */
  delete_advertising_unit: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Advertising Unit 
   * @description Update an advertising unit's properties
   */
  update_advertising_unit: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdvertisingUnitUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AdvertisingUnit"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Advertising Slot 
   * @description Update an advertising slot's sponsor content
   */
  update_advertising_slot: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdvertisingSlotUpdateInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["AdvertisingSlot"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Webhooks */
  list_webhooks: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebhookPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Webhook */
  create_webhook: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebhookInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Webhook"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Webhook 
   * @description Retrieve a specific webhook by its ID
   */
  retrieve_webhook: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Webhook"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Delete Webhook 
   * @description Delete a webhook
   */
  delete_webhook: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Update Webhook 
   * @description Update a webhook's properties
   */
  update_webhook: {
    parameters: {
      path: {
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebhookInput"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Webhook"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Webhook Attempts 
   * @description Retrieve webhook attempts for a specific webhook
   */
  retrieve_webhook_attempts: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["WebhookAttemptOutputPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Test Webhook 
   * @description Send a test event to a webhook
   */
  test_webhook: {
    parameters: {
      query: {
        /**
         * @description Various types of events that are recorded by Buttondown, both in terms of exogenous systems
         * like Stripe and Memberful, and endogenous ones like email opens and clicks. (In general, if anything
         * important ever happens that could be relevant to your newsletter, we have an event type for it!)
         * 
         * These event types power lots of things within Buttondown. They're used to trigger automations, webhooks,
         * and analytics.
         * 
         * (Note that Buttondown also has a different thing we call "events"; those are `EmailEvents` and are used
         * for tracking aggregate details about an email. Alas, we shouldn't have used the term "event" for two different
         * things, but it's too late to go back now!)
         * 
         * In general, our event namespacing tries to hew to the following pattern:
         * 
         * <source>.<object>.<action>
         * 
         * When wondering which object we are referring to, default to the _more granular_ object.
         * 
         * For instance, an email being sent to a subscriber is `subscriber.delivered`, not `email.sent`.
         */
        event_type?: "subscriber.created" | "subscriber.unsubscribed" | "subscriber.changed_email" | "subscriber.confirmed" | "subscriber.trial_started" | "subscriber.trial_ended" | "subscriber.type.changed" | "subscriber.tags.changed" | "subscriber.clicked" | "subscriber.opened" | "subscriber.paid" | "subscriber.churned" | "subscriber.updated" | "subscriber.deleted" | "subscriber.viewed_checkout_page" | "subscriber.replied" | "subscriber.paused" | "subscriber.resumed" | "subscriber.responded_to_survey" | "subscriber.referred" | "subscriber.referred.paid" | "subscriber.commented" | "subscriber.delivered" | "subscriber.complained" | "subscriber.bounced" | "subscriber.rejected" | "survey.created" | "survey.updated" | "survey.deleted" | "survey.cleared_responses" | "email.created" | "email.sent" | "email.updated" | "email.deleted" | "email.status.changed" | "mention.created" | "advertising_slot.purchased" | "social_mention.created" | "export.created" | "export.completed" | "export.failed" | "automation.invoked" | "stripe.checkout.session.completed" | "stripe.subscription.activated" | "stripe.subscription.churning" | "stripe.subscription.deactivated" | "stripe.customer.updated" | "memberful.subscription.created" | "memberful.subscription.deleted" | "memberful.member.updated" | "date.day.started" | "date.week.started" | "date.month.started" | "date.year.started" | "firewall.blocked" | "patreon.membership.created" | "patreon.membership.deleted" | "patreon.member.updated" | "note.created" | "note.deleted" | "external_feed_item.created" | "shopify.customer.created" | "shopify.customer.updated";
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description No Content */
      204: never;
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Retrieve Comment 
   * @description Retrieve a specific comment by its ID
   */
  retrieve_comment: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["Comment"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Comments */
  list_comments: {
    parameters: {
      query: {
        /** @description If provided, only return comments for the given email. */
        email_id?: string;
        /** @description If provided, only return comments for the given subscriber. */
        subscriber_id?: string;
        /** @description If provided, expand the given field. (Only supported fields: 'subscriber', 'email'). */
        expand?: ("subscriber" | "email")[];
        ordering?: "creation_date" | "-creation_date" | "email" | "-email" | "subscriber" | "-subscriber";
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CommentPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Retrieve Survey Responses */
  retrieve_survey_responses: {
    parameters: {
      query: {
        /** @description If provided, only return responses made to the given email. */
        email?: string;
        /** @description If provided, only return responses made by the given subscriber. */
        subscriber?: string;
        /** @description If provided, only return responses made to the given survey(s). */
        survey?: (string)[];
        /** @description If provided, only return responses made after the given date. */
        creation_date__start?: string;
        /** @description If provided, only return responses made before the given date. */
        creation_date__end?: string;
        /** @description If provided, expand the given field. */
        expand?: ("email" | "subscriber" | "survey" | "automation")[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ResponsePage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Survey Response */
  create_survey_response: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResponseInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Response"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** List Events */
  list_events: {
    parameters: {
      query: {
        event_type?: components["schemas"]["EmailEventType"];
        ordering?: "creation_date" | "-creation_date";
        /** @description If provided, expand the given field. (Only supported field: 'subscriber'). */
        expand?: ("automation" | "subscriber" | "email")[];
        email_id?: string;
        automation_id?: string;
        subscriber_id?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["EmailEventPage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /**
   * Get Event 
   * @description Retrieve a specific event by its ID
   */
  get_event: {
    parameters: {
      query: {
        /** @description If provided, expand the given field. (Only supported field: 'subscriber'). */
        expand?: ("automation" | "subscriber" | "email")[];
      };
      path: {
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["EmailEvent"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
    };
  };
  /** List Notes */
  list_notes: {
    parameters: {
      query: {
        /** @description Filter notes by the type of object they are attached to. */
        model_type?: string;
        /** @description Filter notes by the ID of the object they are attached to. */
        model_id?: string;
        /** @description If provided, expand the given field. */
        expand?: ("user")[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["NotePage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
  /** Create Note Endpoint */
  create_note_endpoint: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["NoteInput"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        content: {
          "application/json": components["schemas"]["Note"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorMessage"];
        };
      };
      /** @description Conflict */
      409: never;
    };
  };
}
